{"pages":[],"posts":[{"title":"安装Homebrew遇到connection refused问题解决及Proxifier配置","text":"问题描述刚刚从window转为macOS，很多东西需要重新配置以及熟悉。听说Homebrew是个强大的包管理器，所以用来试试看。在Homebrew官网主页复制了安装命令在终端运行时遇到了connection refused问题 问题解决由于我在境内，需要使用VPN连接，因此我使用的是V2rayU这款开源软件（github地址：https://github.com/yanue/V2rayU），查阅了用户手册后，在代理模式部分看到 全局模式: 有别于vpn,只是将代理信息更新到系统代理http,https,socks,若需要真正全局模式, 推荐搭配使用Proxifier 因此需要Proxifier搭配才能进行全局代理。 添加代理信息安装好Proxifier后还需要进行配置，打开软件，添加代理信息，选择：菜单栏–&gt;&gt;Profile–&gt;&gt;Proxy Servers。 选择add添加服务器，地址填127.0.0.1，端口一般为1080 配置完成在终端即可实现全局代理 远程DNS设置为了防止DNS污染，一般使用代理的时候都会使用远程服务器的DNS设置，具体设置方法是，菜单栏–&gt;&gt;Profile–&gt;&gt;Name Resolution。 然后选择“Resolve hostnames through proxy”即可。（一开始这个选项可能是灰色不能点，将默认的“Detect DNS seetings automatically”点掉即可） 至此，再次尝试在终端安装Homebrew即可。","link":"/2020/06/10/%E5%AE%89%E8%A3%85Homebrew%E9%81%87%E5%88%B0connection-refused%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8F%8AProxifier%E9%85%8D%E7%BD%AE/"},{"title":"MacOS下编译RedisDesktopManagement报no file at...&#x2F;Python.framework&#x2F;...错解决方案","text":"问题描述执行命令：/Users/zzq/Qt5.9.8/5.9.8/clang_64/bin/macdeployqt rdm.app -qmldir=../../../src/qml 出错：ERROR: no file at &quot;/usr/local/opt/python/lib/Python.framework/Versions/3.7/Python&quot; 解决方案该问题是找不到Python.framework，如果你跟笔者一样是用brew安装的，那么就将/usr/local/Cellar/python/3.7.5/Frameworks下的Python.framework文件复制一份到/usr/local/Cellar/python/3.7.5/lib下就行了，我的是3.7.5版本，安装的自己到相应路径下操作即可","link":"/2020/06/29/MacOS%E4%B8%8B%E7%BC%96%E8%AF%91RedisDesktopManagement%E6%8A%A5no-file-at-Python-framework-%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"Homebrew安装指定版本Mysql（以5.7为例）","text":"安装HomebrewHomebrew官网：https://brew.sh/安装途中可能遇到connection refused 问题，可看本人之前发的教程解决 搜索可安装版本$ brew search boost 修改环境变量brew安装的东西都是在 /usr/local/Cellar/ 本人的路径是： /usr/local/Cellar/mysql@5.7/5.7.23/bin mysql版本不同，路径会有一些不同 终端输入命令sudo vim .bash_profile 按i进入insert模式，输入：export PATH=$PATH:/usr/local/Cellar/mysql@5.7/5.7.23/bin 然后esc退出insert模式，并在最下方输入:wq保存退出。（注意“wq”前有个“:”） 生效配置文件source .bash_profile 回车执行，运行环境变量。 自动生效配置文件如果没有这一步，那么每次关掉终端在打开都需要重新source .bash_profile。首先， vi ~/.zshrc 输入： export PATH=${PATH}:/usr/local/Cellar/mysql@5.7/5.7.23/bin 保存后 source ~/.zshrc","link":"/2020/07/18/Homebrew%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%ACMysql%EF%BC%88%E4%BB%A55-7%E4%B8%BA%E4%BE%8B%EF%BC%89/"},{"title":"Homebrew安装Docker Desktop for Mac及MacOS10.15版本的镜像配置方法","text":"搜索Docker的包brew search docker 12345678910111213141516==&gt; Formulaedocker docker-machine-driver-vmwaredocker-clean docker-machine-driver-vultrdocker-completion docker-machine-driver-xhyvedocker-compose docker-machine-nfsdocker-compose-completion docker-machine-parallelsdocker-credential-helper docker-slimdocker-credential-helper-ecr docker-squashdocker-gen docker-swarmdocker-ls docker2acidocker-machine dockerizedocker-machine-completion lazydockerdocker-machine-driver-hyperkit==&gt; Casksdocker-edge homebrew/cask/docker-toolboxhomebrew/cask/docker Casks下的才是Docker Desktop可以使用命令查看信息 brew cask info docker 12345678910111213141516171819==&gt; Tapping homebrew/caskCloning into '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask'...remote: Enumerating objects: 2, done.remote: Counting objects: 100% (2/2), done.remote: Compressing objects: 100% (2/2), done.remote: Total 452026 (delta 0), reused 0 (delta 0), pack-reused 452024Receiving objects: 100% (452026/452026), 205.09 MiB | 5.08 MiB/s, done.Resolving deltas: 100% (320412/320412), done.Tapped 1 command and 3619 casks (3,736 files, 219.9MB).docker: 2.3.0.3,45519 (auto_updates)https://www.docker.com/community-editionNot installedFrom: https://github.com/Homebrew/homebrew-cask/blob/HEAD/Casks/docker.rb==&gt; NamesDocker DesktopDocker Community EditionDocker CE==&gt; ArtifactsDocker.app (App) 安装Dockerbrew cask install docker 123456==&gt; Downloading https://desktop.docker.com/mac/stable/45519/Docker.dmg######################################################################## 100.0%==&gt; Verifying SHA-256 checksum for Cask 'docker'.==&gt; Installing Cask docker==&gt; Moving App 'Docker.app' to '/Applications/Docker.app'.🍺 docker was successfully installed! 安装完成，现在可以从启动台里找到Docker.app了，打开后会在顶部菜单栏里出现 docker logo，并且会弹出登陆界面，登陆后就能正常使用Docker Desktop for Mac了。 # 获取阿里云镜像地址 前往 [阿里云官网](https://www.aliyun.com/?spm=5176.10695662.amxosvpfn.2.26766339P4o7tB) 使用淘宝/支付宝/注册登录，进入控制台 搜索容器镜像服务 获取镜像地址 配置Docker点击小齿轮图形进入设置页面，在Docker Engine配置镜像地址 修改括号内的内容即可：&quot;registry-mirrors&quot;: [ &quot;https://********.mirror.aliyuncs.com&quot; ] 运行Docker在终端输入 docker run hello-world 12Hello from Docker!This message shows that your installation appears to be working correctly.","link":"/2020/07/18/Homebrew%E5%AE%89%E8%A3%85Docker-Desktop-for-Mac%E5%8F%8AMacOS10-15%E7%89%88%E6%9C%AC%E7%9A%84%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"title":"Eight rounding modes八种舍入模式解析","text":"读《Effective Java》Item 60 : Avoid float and double if exact answers are required的时候，结尾写BigDecimal的优点时写道 Using BigDecimal has the added advantage that it gives you full control over rounding, letting you select from eight rounding modes whenever an operation that entails rounding is performed. 这里的eight rounding modes（八种舍入模式）第一次看到，查找资料记录一下 ROUND_UP舍入远离零的舍入模式。在丢弃非零部分之前始终增加数字（始终对非零舍弃部分前面的数字加1）。即，有小数位的情况下，去掉小数位，正数+1，负数-1 ROUND_DOWN接近零的舍入模式。在丢弃某部分之前始终不增加数字（从不对舍弃部分前面的数字加1，即截短）。即，有小数位的情况下，去掉小数位，整数位不变 ROUND_CEILING接近正无穷大的舍入模式。如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同；如果为负，则舍入行为与 ROUND_DOWN 相同。即，有小数位的情况下，去掉小数位，正数+1，负数不变! ROUND_FLOOR接近负无穷大的舍入模式。如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同；如果为负，则舍入行为与 ROUND_UP 相同。即，有小数位的情况下，去掉小数位，正数不变，负数-1 ROUND_HALF_UP向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分 &gt;= 0.5，则舍入行为与 ROUND_UP 相同；否则舍入行为与 ROUND_DOWN 相同。即，四舍五入 ROUND_HALF_DOWN向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。如果舍弃部分 &gt; 0.5，则舍入行为与 ROUND_UP 相同；否则舍入行为与 ROUND_DOWN 相同。即，五舍六入 ROUND_HALF_EVEN向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同；如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况。如果前一位为奇数，则入位，否则舍去。以下例子为保留小数点1位，那么这种舍入方式下的结果。1.15&gt;1.2 1.25&gt;1.2 ROUND_UNNECESSARY断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。 参考http://www.blogjava.net/wangzc2001/archive/2010/12/17/340988.html","link":"/2020/07/23/Eight-rounding-modes%E5%85%AB%E7%A7%8D%E8%88%8D%E5%85%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90/"},{"title":"Homebrew常用命令","text":"本文为Homebrew的常用命令，便于日常操作 常用命令12345678910brew help 查看帮助brew install &lt;package name&gt; 安装软件包brew uninstall &lt;package name&gt; 卸载软件包brew list [--versions] 列出已安装的软件包(包括版本)brew search &lt;package name&gt; 查找软件包brew info &lt;package name&gt; 查看软件包信息brew update 更新brewbrew outdated 列出过时的软件包（已安装但不是最新版本）brew upgrade [&lt;package name&gt;] 更新过时的软件包（不指定软件包表示更新全部）brew doctor 检查brew运行状态 常用软件1234567brew install wgetbrew install curlbrew install opensslbrew install fish #安装fish shellbrew install git-flow #安装git-flowbrew install python #安装python Homebrew-CaskHomebrew-Cask 是 Homebrew 的一个扩展。它能够优雅、简单、快速的安装和管理 macOS 图形界面程序，比如Google Chrome 和Dropbox等等。官网 https://caskroom.github.io/。 Cask 必装的理由有图形界面的软件可以直接在 App Stroe 中下载更新，为啥还需要 Cask 呢？因为有的很好用的免费 Mac 软件并没有选择在 App Store 上架，对于没有上架的软件我们只能是通过搜索找到官网然后在下载安装包，这样不够优雅也不方便管理，而使用 Cask 可以通过一行命令就搞定安装了，还可以统一更新升级所有的软件，实现从非 App Store 途径安装的软件的统一管理。Cask 从软件官方网站下载软件包，然后在后台安装并将 .app 移动到 Applications。通过 Cask 安装的软件也会在 Lanuchpad 显示，跟从 App Store 安装的软件没啥区别。对于那些收费的软件，用 Cask 安装只是比普通安装方法节省了时间和步骤，没啥其他的区别。 Cask 常用命令123456brew cask -help 查看帮助brew cask install &lt;software name&gt; 安装软件brew cask uninstall &lt;software name&gt; 卸载软件brew cask search &lt;software name&gt; 搜索软件brew cask info &lt;software name&gt; 查看软件相关信息brew cask list 列出通过 Homebrew-Cask 安装的包 经过测试，虽然 -help 是未知命令，但是仍然可查看 Cask 的命令，其他帮助命令（如 brew cask -h 和 brew cask –help）好像都不行。还有其他的命令就不一一介绍了，其他命令可以通过brew cask -help查看。 Cask 常用软件12345678910111213141516brew cask install iterm2 #安装iTerm 2brew cask install launchrocket #管理软件后台服务brew cask install google-chrome #安装Chromebrew cask install the-unarchiver #解压软件brew cask install alfred #效率软件brew cask install qq #腾讯QQbrew cask install evernote #云笔记软件brew cask install sublime-text #文本编辑器brew cask install skitch #ervernote配套的截图软件brew cask install dropbox #文件同步软件brew cask install zotero #网页收藏与文献管理软件brew cask install anki #记忆软件brew cask install virtualbox #虚拟机，可以装个Windowsbrew cask install self-control #避免分心的软件brew cask install vlc #视频软件brew cask install appcleaner #应用清理 Quick Look 系列12345brew cask install qlcolorcode #预览脚本时自动代码配色brew cask install qlstephen #预览未知拓展名的纯文本文件brew cask install qlmarkdown #预览Markdown文件brew cask install quicklook-json #预览JSON文件brew cask install quicklook-csv #预览CSV文件 Homebrew-Cask 是一个开源项目，其详细信息可以看其开源项目介绍，所支持的软件列表在这里：https://github.com/caskroom/homebrew-cask/tree/master/Casks 。如果觉得管理软件在后台运行的服务很麻烦，可以装个LaunchRocket，这也是个开源项目。关于 Quick Look 的介绍可以看这篇文章加强你的「一指禅」：Mac QuickLook「快速预览」兼容性扩展教程，同时Quick Look plugins这个开源项目列出了所有支持 Homebrew-Cask 的 Quick Look 扩展，据说支持的都是程序员必备。 轻松实现一键装机在使用 Mac 的过程中，总想着有没有方便、简单的办法实现在不同Mac 上同步开发环境的办法，今天在整理 Homebrew 使用笔记的时候突然冒出一个想法，如果我把所有的 Homebrew 安装命令列成一个清单形式，当在另一台新的 Mac 上工作时，那么就可以先装一个 Homebrew 然后将命令清单中的所有命令复制粘贴到终端中，等待命令执行完毕后，新的 Mac 的大部分开发环境就跟常用的 Mac 开发环境一致了。下面列出笔者的常用命令清单： 12345678910#安装 Homebrew/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"#安装基础套件brew install fish #安装fish shellbrew install git-flow #安装git-flowbrew install python #安装python#Homebrew-Caskbrew tap caskroom/cask 安装Cask基础软件12345678brew cask install iterm2 #安装iTerm 2brew cask install visual-studio-code#微软出品的文本编辑器，可替代 Sublime Textbrew cask install google-chrome #安装Chromebrew cask install the-unarchiver #解压软件brew cask install alfred #效率软件brew cask install qq #腾讯QQbrew cask install sourcetree #Git GUI 客户端brew cask install cheatsheet # 显示当前程序的快捷键列表，默认的快捷键是长按⌘ 参考https://www.cnblogs.com/javalouvre/p/10618340.html","link":"/2020/07/19/Homebrew%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"MacOS下安装JDK并配置路径以解决Homebrew安装Maven后的Java路径不匹配问题","text":"本文记录首次安装JDK及解决Maven路径不匹配问题 安装JDK前往 Oracle官网选择对应版本下载，安装时一路Next即可 验证JDK在终端输入java -version 123java version \"1.8.0_261\"Java(TM) SE Runtime Environment (build 1.8.0_261-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode) 表示已经安装成功，也能正常使用，但此时是没有配置路径的 Homebrew安装的maven中路径与系统Java路径不匹配 Homebrew安装maven方法可参考本人之前的安装mysql的文章 使用Homebrew安装好maven后，在终端输入mvn -v 12345Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)Maven home: /usr/local/Cellar/maven@3.5/3.5.4_1/libexecJava version: 14.0.1, vendor: N/A, runtime: /usr/local/Cellar/openjdk/14.0.1/libexec/openjdk.jdk/Contents/HomeDefault locale: zh_CN_#Hans, platform encoding: UTF-8OS name: \"mac os x\", version: \"10.15.4\", arch: \"x86_64\", family: \"mac\" 可以看到，这里的Java版本是14.0.1，这是因为使用Homebrew安装maven的时候会一并安装最新版本的OpenJDK。因此需要我们手动配置一下。 配置Java路径 参考来源：https://www.jianshu.com/p/6831bfb8e012 在终端输入sudo vim /etc/profile按i进入insert模式，在下方加入四行配置 1234JAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home\"export JAVA_HOMECLASS_PATH=\"$JAVA_HOME/lib\"PATH=\".$PATH:$JAVA_HOME/bin\" 输入:wq!保存并退出 1JAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home\" 此处的路径可以去资源库查找自己的路径，也可以打开一个新的终端输入 /usr/libexec/java_home 然后把出现的路径复制过来就行完成上面内容后继续在终端输入 source /etc/profile 回车后即完成配置。 验证配置是否成功终端输入 echo $JAVA_HOME 出现Java路径即成功！ 配置完成后再查看maven，可发现Java已显示为自己安装的1.8版本 12345Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)Maven home: /usr/local/Cellar/maven@3.5/3.5.4_1/libexecJava version: 1.8.0_261, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: \"mac os x\", version: \"10.15.4\", arch: \"x86_64\", family: \"mac\"","link":"/2020/07/21/MacOS%E4%B8%8B%E5%AE%89%E8%A3%85JDK%E5%B9%B6%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84%E4%BB%A5%E8%A7%A3%E5%86%B3Homebrew%E5%AE%89%E8%A3%85Maven%E5%90%8E%E7%9A%84Java%E8%B7%AF%E5%BE%84%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"},{"title":"Mac使用Marginnote3时，启动会自动打开固定某一个笔记解决方案","text":"本文记录使用Marginnote3时，第一次启动会固定打开某一个笔记本的解决方案 这个问题是笔记本链接的问题 打开 12~/Library/Containers/QReader.MarginStudyMac/Data/Library/Preferences~/Library/Containers/QReader.MarginStudyMac/Data/Library/SyncedPreferences 这两个目录下， 删掉“QReader.MarginStudyMac.plist”这个文件。 打开云同步再同步一遍笔记即可。","link":"/2020/07/22/Mac%E4%BD%BF%E7%94%A8Marginnote3%E6%97%B6%EF%BC%8C%E5%90%AF%E5%8A%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E5%9B%BA%E5%AE%9A%E6%9F%90%E4%B8%80%E4%B8%AA%E7%AC%94%E8%AE%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"MySQL基础语法","text":"读《MySQL必知必会》学习MySQL基础语法，记录一下 USE 使用crashcourse数据库 1USE crashcourse; USE语句不返回任何结果。 SHOW 显示数据库名 1SHOW DATABASES; 显示当前选择的数据库内可用表的列表 1SHOW TABLES; 给出表名，对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（如字段cust_id的auto_increment） 1SHOW COLUMNS FROM customers; NOTE：自动增量auto_increment 某些表列需要唯一值。 在每个行添加到表中时， MySQL可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样做必须记住最后一次使用的值） 。如果需要它，则必须在用CREATE语句创建表时把它作为表定义的组成部分。 其他SHOW语句： SHOW STATUS，用于显示广泛的服务器状态信息； SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句； SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限； SHOW ERRORS和SHOW WARNINGS， 用来显示服务器错误或警告消息。 SELECT 用SELECT语句从products表中检索一个名为prod_name的列 （如果没有明确排序查询结果 ，则返回的数据的顺序没有特殊意义 ） 12SELECT prod_nameFROM products; 从products表中选择3列 12SELECT prod_id, prod_name, prod_priceFROM products; 检索所有列 12SELECT *FROM products; 检索不同的行，只返回不同的vend_id行 12SELECT DISTINCT vend_idFROM products; LIMIT 限制结果。使用LIMIT 5返回不多于5行 123SELECT prod_nameFROM productsLIMIT 5; NOTE：LIMIT 为得出下一个5行，可以指定开始行和行数，如LIMIT 5,5，表示从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数。 行0：检索出来的第一行为行0而不是行1。因此， LIMIT 1, 1将检索出第二行而不是第一行。 在行数不够时 ，MySQL将只返回它能返回的那么多行 使用完全限定的表名 12SELECT products.prod_nameFROM crashcourse.products; ORDER BY 使用ORDER BY子句取一个或多个列的名字，据此对输出进行排序 123SELECT prod_nameFROM productsORDER BY prod_name; 按多个列排序。检索3个列，并按其中两个列对结果进行排序，首先按价格，然后再按名称排序 123SELECT prod_id, prod_price, prod_nameFROM productsORDER BY prod_price, prod_name; 按降序排序。 123SELECT prod_id, prod_price, prod_nameFROM productsORDER BY prod_price DESC; 使用ORDER BY和LIMIT组合，prod_price DESC保证行由最贵到最便宜检索，LIMIT 1告诉MySQL仅返回一行 1234SELECT prod_priceFROM productsORDER BY prod_price DESCLIMIT 1; NOTE：ORDER BY子句的位置 在给出ORDER BY子句时，应该保证它位于FROM子句之后。如果使用LIMIT，它必须位于ORDER BY之后。 WHERE 在SELECT语句中，数据根据WHERE子句指定的搜索条件进行过滤。 123SELECT prod_name, prod_priceFROM productsWHERE prod_price = 2.50; NOTE： SQL过滤与应用过滤。数据也可以在应用层过滤。为此目的， SQL的SELECT语句为客户机应用检索出超过实际所需的数据，然后客户机代码对返回数据进行循环，以提取出需要的行。通常，这种实现并不令人满意。因此，对数据库进行了优化，以便快速有效地对数据进行过滤。让客户机应用（或开发语言）处理数据库的工作将会极大地影响应用的性能，并且使所创建的应用完全不具备可伸缩性。此外，如果在客户机上过滤数据，服务器不得不通过网络发送多余的数据，这将导致网络带宽的浪费。 WHERE子句的位置。在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后 WHERE子句操作符 123456789101112131415161718192021222324#检查单个值SELECT prod_name, prod_priceFROM productsWHERE prod_name = 'fuses';#列出小于10元的产品SELECT prod_name, prod_priceFROM productsWHERE prod_price &lt; 10;#不匹配检查SELECT vend_id, prod_nameFROM productsWHERE vend_id != 1003;#范围检查SELECT prod_name, prod_priceFROM productsWHERE prod_price BETWEEN 5 AND 10;#空值检查SELECT prod_nameFROM productsWHERE prod_price IS NULL; AND OR AND`操作符，必须满足所有条件 123SELECT prod_id, prod_price, prod_nameFROM productsWHERE vend_id = 103 AND prod_price &lt;= 10; OR操作符，匹配任一条件即可 123SELECT prod_name, prod_priceFROM productsWHERE vend_id = 1002 OR vend_id = 1003; AND和OR组合使用。列出价格为10元（含）以上且由1002或1003制造的所有产品 123SELECT prod_name, prod_priceFROM productsWHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10; NOTE： SQL的计算次序中AND的优先级比OR更高，因此在不加括号时会优先计算AND两侧条件 任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序。 IN IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配 1234SELECT vend_id, prod_name, prod_priceFROM productsWHERE vend_id IN (1002,1003)ORDER BY prod_name; NOTE：IN操作符优点 在使用长的合法选项清单时， IN操作符的语法更清楚且更直观。 在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。 IN操作符一般比OR操作符清单执行更快。 IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。 NOT WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。 1234SELECT vend_id, prod_name, prod_priceFROM productsWHERE vend_id NOT IN (1002,1003)ORDER BY prod_name; NOTE：MySQL中的NOT MySQL 支 持 使 用 NOT 对 IN 、 BETWEEN 和EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。 LIKENOTE： 通配符（wildcard）：用来匹配值的一部分的特殊字符 搜索模式（search pattern）：由字面值、通配符或两者组合构成的搜索条件 谓词（predicate）： 操作符何时不是操作符？答案是在它作为谓词（ predicate）时。从技术上说， LIKE是谓词而不是操作符。虽然最终的结果是相同的，但应该对此术语有所了解 百分号（%）通配符。 例：找出所有以词jet起头的产品 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE 'jet%'; 匹配任意位置 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '%anvil%'; 找出s起头以e结尾所有产品 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE 's%e'; NOTE： 注意尾空格：尾空格可能会干扰通配符匹配。例如，在保存词anvil 时 ， 如 果 它 后 面 有 一 个 或 多 个 空 格 ， 则 子 句 WHEREprod_name LIKE ‘%anvil’将不会匹配它们，因为在最后的l后有多余的字符。解决这个问题的一个简单的办法是在搜索模式最后附加一个%。一个更好的办法是使用函数 注意NULL：虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。即使是WHERE prod_name LIKE ‘%’也不能匹配用值NULL作为产品名的行 下划线（_）通配符。用途与%一样，但下划线只匹配单个字符而不是多个字符。 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '_ ton anvil'; 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '% ton anvil'; NOTE： 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据 正则表达式 基本字符匹配。 1234SELECT prod_idFROM productsWHERE prod_name REGEXP '.000';ORDER BY prod_name; NOTE：匹配不区分大小写。 MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXPBINARY 'JetPack .000' 进行OR匹配。也可以给出两个以上的OR条件，如1000|2000|3000 1234SELECT prod_idFROM productsWHERE prod_name REGEXP '1000|2000';ORDER BY prod_name; 匹配几个字符之一。使用正则表达式[123]定义一组数字，匹配1或2或3 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[123] Ton';ORDER BY prod_name; 范围匹配 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[1-5] Ton';ORDER BY prod_name; 匹配特殊字符。如果使用.，则会匹配任意字符 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '\\\\.';ORDER BY prod_name; NOTE： 匹配\\。为了匹配\\本身，需要使用\\\\\\ **\\或\\\\?**。多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（ MySQL自己解释一个，正则表达式库解释另一个）。 匹配字符类 匹配多个实例 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '\\\\([0-9] sticks?\\\\)';ORDER BY prod_name; 分析：正则表达式\\\\([0-9] sticks?\\\\)需要解说一下。 \\\\(匹配(，[0-9]匹配任意数字（这个例子中为1和5），sticks?匹配stick和sticks（ s后的?使s可选，因为?匹配它前面的任何字符的0次或1次出现），\\\\)匹配)。没有?，匹配stick和sticks会非常困难 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[[:digit:]]{4}';ORDER BY prod_name; 分析：[:digit:]匹配任意数字，因而它为数字的一个集合。 {4}确切地要求它前面的字符（任意数字）出现4次，所以[[:digit:]]{4}匹配连在一起的任意4位数字 定位符 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '^[0-9\\\\.]';ORDER BY prod_name; 分析：之前的例子都是匹配一个串中任意位置的文本。^[0-9\\\\.]只在.或任意数字为串中第一个字符时才匹配它们 NOTE：使REGEXP起类似LIKE的作用。LIKE和REGEXP的不同在于， LIKE匹配整个串而REGEXP匹配子串。利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一样。 计算字段 例：vendors表包含供应商名和位置信息。假如要生成一个供应商报表，需要在供应商的名字中按照name(location)这样的格式列出供应商的位置。此报表需要单个值，而表中数据存储在两个列vend_name和vend_country中。此外，需要用括号将vend_country括起来。 123SELECT Concat(vend_name, '(', vend_country, ')')FROM vendorsORDER BY vend_name; 使用RTrim()函数删除数据右侧多余的空格来整理数据。也可以使用LTrim()删除左边的空格，Trim()删除左右两边的空格 123SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')')FROM vendorsORDER BY vend_name; 使用别名。使用AS关键字将vend_title作为新计算列的名字 1234SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')') ASvend_titleFROM vendorsORDER BY vend_name; NOTE： 别名的其他用途。别名还有其他用途。常见的用途包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它。 导出列。别名有时也称为导出列（ derived column），不管称为什么，它们所代表的都是相同的东西。 执行算术运算 1234567SELECT prod_id, quantity, item_price, order_num, quantity * item_price AS expanded_priceFROM orderitemsWHERE order_num = 20005; 函数NOTE：函数没有SQL的可移植性强。 能运行在多个系统上的代码称为可移植的（ portable）。相对来说，多数SQL语句是可移植的，在SQL实现之间有差异时，这些差异通常不那么难处理。而函数的可移植性却不强。几乎每种主要的DBMS的实现都支持其他实现不支持的函数，而且有时差异还很大。 为了代码的可移植，许多SQL程序员不赞成使用特殊实现的功能。虽然这样做很有好处，但不总是利于应用程序的性能。如果不使用这些函数，编写某些应用程序代码会很艰难。必须利用其他方法来实现DBMS非常有效地完成的工作。 如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义 本文处理函数 123SELECT vend_name, Upper(vend_name) AS vend_name_upcaseFROM vendorsORDER BY vend_name; 常用文本处理函数 Soundex()通过发音字符和音节检索 123SELECT cust_name, cust_contactFROM customersWHERE Soundex(cust_contact) = Soundex('Y Lie'); 常用日期和时间处理函数 检索2005年9月1日订单记录 123SELECT order_date, cust_id, order_numFROM ordersWHERE Date(order_date) = '2005-09-01'; 检索2005年9月所有订单 123SELECT cust_id, order_numFROM ordersWHERE Year(order_date) = 2005 AND Month(order_date) = 9; 数值处理函数 汇总数据 AVG()函数 12SELECT AVG(prod_price) AS avg_priceFROM products; 123SELECT AVG(prod_price) AS avg_priceFROM productsWHERE vend_id = 1003;#返回特定供应商产品平均价格 NOTE： **只用于单个列 AVG()**。只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。 NULL值。AVG()函数忽略列值为NULL的行 COUNT()函数 123#返回customers表中客户的总数SELECT COUNT(*) AS num_custFROM customers; 123#只对具有电子邮件地址的客户计数SELECT COUNT(cust_email) AS num_custFROM customers; MAX()函数 123#返回products表中最贵物品的价格SELECT MAX(prod_price) AS max_priceFROM products; NOTE： 对非数值数据使用MAX()。虽然MAX()一般用来找出最大的数值或日期值，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行 NULL值。MAX()函数忽略列值为NULL的行。 MIN()函数 12SELECT MIN(prod_price) AS min_priceFROM products; SUM()函数 12345678#检索订购物品的总数SELECT SUM(quantity) AS items_orderedFROM orderitemsWHERE order_num = 20005;#合计计算值SELECT SUM(item_price * quantity) AS total_priceFROM orderitemsWHERE order_num = 20005; 聚集不同值，DISTINCT 1234#平均值只考虑各个不同的价格SELECT AVG(DISTINCT prod_price) AS avg_priceFROM productsWHERE vend_id = 1003; 组合聚集函数 12345SELECT COUNT(*) AS num_items, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avgFROM products; 分析：这里用单条SELECT语句执行了4个聚集计算，返回4个值（products表中物品的数目，产品价格的最高、最低以及平均值） 分组数据 GROUP BY创建分组 1234#对每个vend_id计算num_prods一次SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_id; NOTE： GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集计算语句外， SELECT语句中的每个列都必须在GROUP BY子句中给出。 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后， ORDER BY子句之前。 1234#使用ROLLUP对每个组及每个分组汇总SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_id WITH ROLLUP; HAVING过滤分组 1234SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_idHAVING COUNT(*) &gt;= 2; WHERE与HAVING同时使用的情况 123456#通过WHERE进一步过滤上面的例子SELECT vend_id, COUNT(*) AS num_prodsFROM productsWHERE prod_price &gt;= 10GROUP BY vend_idHAVING COUNT(*) &gt;= 2; ORDER BY与GROUP BY 1234SELECT order_num, SUM(quantity*item_price) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantity*item_price) &gt;= 50; 123456#将总计订单价格排序输出SELECT order_num, SUM(quantity*item_price) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantity*item_price) &gt;= 50ORDER BY ordertotal; 子查询1234567891011#检索订购物品TNT2的所有客户#通过客户ID查询客户信息SELECT cust_name, cust_contactFROM customers#外部查询，通过返回的订单号查询客户IDWHERE cust_id IN(SELECT cust_id FROM orders #内部查询，检索包含TNT2的所有订单编号 WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2')); NOTE： 列必须匹配。在WHERE子句中使用子查询（如这里所示），应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。 子查询和性能。这里给出的代码有效并获得所需的结果。但是，使用子查询并不总是执行这种类型的数据检索的最有效的方法。 联结表12345#创建联结SELECT vend_name, prod_name, prod_priceFROM vendors, productsWHERE vendors.vend_id = products.vend_idORDER BY vend_name, prod_name; NOTE： 完全限定列名。在引用的列可能出现二义性时，必须使用完全限定列名（用一个点分隔的表名和列名）。如果引用一个没有用表名限制的具有二义性的列名， MySQL将返回错误。 不要忘了WHERE子句。应该保证所有联结都有WHERE子句，否则MySQL将返回比想要的数据多得多的数据。同理，应该保证WHERE子句的正确性。不正确的过滤条件将导致MySQL返回不正确的数据。 叉联结。有时我们会听到返回称为叉联结（ cross join）的笛卡儿积的联结类型。 内部联结 123SELECT vend_name, prod_name, prod_priceFROM vendors INNER JOIN productsON vendors.vend_id = products.vend_id; 分析：这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同 联结多个表 12345SELECT prod_name, vend_name, prod_price, quantityFROM orderitems, products, vendorsWHERE products.vend_id = vendors.vend_id AND orderitems.prod_id = products.prod_id AND order_num = 20005; 分析：显示编号为20005的订单中的物品。订单物品存储在orderitems表中。每个产品按其产品ID存储，它引用products表中的产品。这些产品通过供应商ID联结到vendors表中相应的供应商，供应商ID存储在每个产品的记录中。这里的FROM子句列出了3个表，而WHERE子句定义了这两个联结条件，而第三个联结条件用来过滤出订单20005中的物品 NOTE：性能考虑 MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害 对比子查询 1234567891011121314151617#返回订购产品TNT2的客户列表#子查询SELECT cust_name, cust_contactFROM customers#外部查询，通过返回的订单号查询客户IDWHERE cust_id IN(SELECT cust_id FROM orders #内部查询，检索包含TNT2的所有订单编号 WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2'));#联结查询SELECT cust_name, cust_contactFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_id AND orderitems.order_num = orders.order_num AND prod_id = 'TNT2';","link":"/2020/06/10/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"【Spring源码】深入理解Spring IoC","text":"一开始学习Spring的时候就接触IoC了，作为Spring第一个最核心的概念，我们在解读它的源码之前必须要对其有深入的认识，本篇主要介绍IoC基本概念和各个组件。 本文主要基于 Spring 5.0.6.RELEASE IoC介绍IoC全称为Inversion of Control即“控制反转”，它还有一个别名DI（Dependency Injection），即“依赖注入”。 如何理解“控制反转”？关键在于我们需要回答下面四个问题： 谁控制谁 控制什么 为什么是反转 哪些方面反转了 回答这四个问题前，我们先看IoC的定义： 所谓IoC，就是由Spring IoC容器来负责对象的生命周期和对象之间的关系。 这句话是IoC理论的核心，如何来理解这句话？我们引用一个例子来阐述。 找女朋友，一般情况下是如何找的呢？首先我们要根据自己的喜好（漂亮、身材好、性格好）找一个妹子，然后到处打听她的兴趣爱好、电话号码，然后各种投其所好追到手。如下： 123456789101112131415161718192021222324/** * 年轻小伙子 */public class YoungMan { private BeautifulGirl beautifulGirl; YoungMan(){ // 可能你比较厉害，指腹为婚 // beautifulGirl = new BeautifulGirl(); } public void setBeautifulGirl(BeautifulGirl beautifulGirl) { this.beautifulGirl = beautifulGirl; } public static void main(String[] args){ YoungMan you = new YoungMan(); BeautifulGirl beautifulGirl = new BeautifulGirl(\"你的各种条件\"); beautifulGirl.setxxx(\"各种投其所好\"); // 然后你有女票了 you.setBeautifulGirl(beautifulGirl); }} 这就是我们通常做事的方式，如果我们需要某个对象，一般都是采用这种直接创建的方式（new BeautifulGirl()），这个过程复杂而又繁琐，而且我们必须要面对每个环节，在使用完成之后还需要复杂地销毁它，这种情况下我们的对象与它所依赖的对象耦合在一起。 其实我们需要思考一个问题，我们每次用到自己依赖的对象真的需要自己去创建吗？我们知道，我们依赖的对象其实并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是我们主动去创建的还是别人送给我们的，其实并不是那么重要。 这个给我们送东西的“人”就是IoC，在上面的例子中，它就相当于一个婚介公司，作为一个婚介公司它管理者很多男男女女的资料，当我们需要一个女朋友的时候，直接跟婚介公司提出我们的需求，婚介公司则会根据我们的需求提供一个妹子给我们，我们只需要负责谈恋爱就行了。 作为婚介公司的IoC帮我们省略了找女朋友的繁琐过程，将原来的主动寻找变成了现在的被动接受，更加简介轻便。原来需要各种鞍前马后亲力亲为的事，现在直接有人把现成的送过来，多么美妙的事情啊。所以，IoC的理念就是让别人为你服务，如下图（摘自Spring揭秘）： 在没有引入IoC的时候，被引入的对象直接依赖于被依赖的对象，有了Ioc后，两者及他们的关系都是通过Ioc Service Provider来统一管理维护的。被注入的对象需要什么，直接跟IoC Service Provider打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到IoC Service Provider为被注入对象服务的目的。所以有了IoC，原来需要什么东西自己去拿，现在是需要什么让别人（IoC Service Provider）送过来。 现在看看上面那四个问题，答案就很明显了： 谁控制谁：在传统的开发模式下，我们都是采用直接new一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了IoC容器后，则直接由IoC容器来控制。所以“谁控制谁”，当然是IoC容器控制对象。 控制什么：控制对象 为什么是反转：没有IoC的时候我们都是在自己对象中主动区创建被依赖的对象，这就是正转。但是有了IoC后，所依赖的对象直接由IoC容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。 哪些方面反转了：所依赖对象的获取被反转了。 妹子有了，但是如何拥有妹子呢？这也是一门学问。 可能你比较厉害，刚出生就指腹为婚了 大多数情况我们还是会考虑自己想要什么样的妹子，所以还是需要向婚介公司打招呼的 还有一种情况就是，你根本不知道自己想要什么样的妹子，直接跟婚介公司说，我想要一个妹子 注入形式所以，IoC Service Provider为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、setter方法注入、接口注入 构造方法注入顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。 123YoungMan(BeautifulGirl beautifulGirl) { this.beautifulGirl = beautifulGirl;} 构造方法注入比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你制定了媳妇 setter方法注入对于JavaBean对象而言，我们一般都是通过getter和setter方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的setter方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。 12345678public class YoungMan { private BeautifulGirl beautifulGirl; public void setBeautifulGirl(BeautifulGirl beautifulGirl) { this.beautifulGirl = beautifulGirl; }} 相比于构造器注入，setter方式注入会显得比较宽松灵活一些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼。 接口方式注入接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般不推荐这种方式。感兴趣的可以看看《依赖注入的三种实现形式 —— 接口注入（Interface Injection）》 推荐文章关于 IoC 理论部分，笔者不在阐述，这里推荐几篇博客阅读： 《谈谈对 Spring IoC 的理解》 《Spring 的 IoC 原理[通俗解释一下]》 《Spring IoC 原理（看完后大家可以自己写一个spring）》 各个组件先看下图（摘自：http://singleant.iteye.com/blog/1177358） 该图为ClassPathXmlApplicationContext的类继承体系结构，虽然只有一部分，但是它基本上包含了IoC体系中大部分的核心类和接口。 下面我们就针对这个图进行简单的拆分和补充说明。 Resource 体系org.springframework.core.io.Resource，对资源的抽象。它的每一个实现类都代表了一种资源的访问策略，如ClassPathResource、RLResource、FileSystemResource 等。 ResourceLoader 体系有了资源，就应该有资源加载，Spring利用org.springframework.core.io.ResourceLoader来进行统一资源加载，类图如下： （关于Resource和ResourceLoader的源码解析，见…） BeanFactory 体系org.springframework.beans.factory.BeanFactory，是一个非常纯粹的bean容器，它是IoC必备的数据结构，其中BeanDefinition是它的基本结构。BeanFactory内部维护着一个BeanDefinition map，并可根据BeanDefinition的描述进行bean的创建和管理。 BeanFactory 有三个直接子类ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 。 DefaultListableBeanFactory 为最终默认实现，它实现了所有接口。 BeanDefinition 体系org.springframework.beans.factory.config.BeanDefinition ，用来描述 Spring 中的 Bean 对象。 BeanDefinitionReader 体系org.springframework.beans.factory.support.BeanDefinitionReader 的作用是读取 Spring 的配置文件的内容，并将其转换成 Ioc 容器内部的数据结构 ：BeanDefinition 。 关于BeanDefinitionReader 的源码解析，见如下文章： ApplicationContext 体系org.springframework.context.ApplicationContext ，这个就是大名鼎鼎的 Spring 容器，它叫做应用上下文，与我们应用息息相关。它继承 BeanFactory ，所以它是 BeanFactory 的扩展升级版，如果BeanFactory 是屌丝的话，那么 ApplicationContext 则是名副其实的高富帅。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有： 继承 org.springframework.context.MessageSource 接口，提供国际化的标准访问策略。 继承 org.springframework.context.ApplicationEventPublisher 接口，提供强大的事件机制。 扩展 ResourceLoader ，可以用来加载多种 Resource ，可以灵活访问不同的资源。 对 Web 应用的支持。 下图来源：https://blog.csdn.net/yujin753/article/details/47043143 小结上面的五个体系可以说是 Spring IoC 中最核心的部分，后面的博文也是针对这五个部分进行源码分析。其实IoC乍一看还是挺简单的，无非就是将配置文件（暂且认定是xml文件）进行解析，然后放到一个Map里面就差不多了。初看有道理，其实要面临的问题还是有很多的。 此系列博文为笔者学习、研究 Spring 机制和源码的学习笔记，会涉及参考别人的博文和书籍内容，如有雷同，纯属借鉴，当然 LZ 会标明参考来源。同时由于知识面和能力的问题，文章中难免会出现错误之处，如有，望各位大佬指出，不胜感激。","link":"/2020/08/21/%E3%80%90Spring%E6%BA%90%E7%A0%81%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring-IoC/"},{"title":"Java实现批量去除文件、文件夹的名称中指定的字符","text":"有时候下载的文件/文件夹会带有广告后缀，通过Java实现批量去除 实现效果Before After 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.we;import java.io.File;/** * 批量去除文件、文件夹的名称中指定的字符 */public class ClearAdvert { //AD为广告内容 public static final String AD = \"要去除的字符\"; public static int fileNum = 0; public static void main(String[] args) { //文件夹路径名 String rootPath = \"指定的文件（夹）路径\"; scanFile(rootPath); System.out.println(\"共去广告\" + fileNum + \"个文件\"); } /* * 递归调用查找指定文件夹下所有文件 */ public static void scanFile(String path) { File dirFile = reName(new File(path)); System.out.println(dirFile.getAbsolutePath()); if (dirFile.isDirectory()){ String[] fileList = dirFile.list(); for (int i = 0; i &lt; fileList.length; i++) { // windows系统写法 path = dirFile.getAbsolutePath() + \"\\\\\" + fileList[i]; // macOS系统写法 // path = dirFile.getAbsolutePath() + \"/\" + fileList[i]; scanFile(path); } } } public static File reName(File oldFile) { //不带路径的文件名 String originalName = oldFile.getName(); if (originalName.contains(AD)) { //带路径的文件名 String oldFilePath = oldFile.getAbsolutePath();// 目录路径 String newFilePath = oldFilePath.replace(AD, \"\"); File newFile = new File(newFilePath); if (oldFile.renameTo(newFile)) { fileNum++; return newFile; } } return oldFile; }} 参考https://blog.csdn.net/qq_41616414/article/details/102793368 （增加macOS路径写法）","link":"/2020/08/22/Java%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E5%8E%BB%E9%99%A4%E6%96%87%E4%BB%B6%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E5%90%8D%E7%A7%B0%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6/"},{"title":"【Spring源码】IoC之Spring统一资源加载策略","text":"在学 Java SE 的时候，我们学习了一个标准类java.net.URL，该类在 Java SE中定位为统一资源定位器（Uniform Resource Locator），但是我们知道它的实现基本只限于网络形式发布的资源的查找和定位。然而，实际上资源的定义比较广泛，除了网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等。而且它可以存在于任何场所，比如网络、文件系统、应用程序中。所以java.net.URL的局限性迫使 Spring 必须实现自己的资源加载策略，该资源加载策略需要满足如下要求： 职能划分清楚。资源的定义和资源的加载应该要有一个清晰地界限； 统一的抽象。统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来界定。 前言在学 Java SE 的时候，我们学习了一个标准类java.net.URL，该类在 Java SE中定位为统一资源定位器（Uniform Resource Locator），但是我们知道它的实现基本只限于网络形式发布的资源的查找和定位。然而，实际上资源的定义比较广泛，除了网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等。而且它可以存在于任何场所，比如网络、文件系统、应用程序中。所以java.net.URL的局限性迫使 Spring 必须实现自己的资源加载策略，该资源加载策略需要满足如下要求： 职能划分清楚。资源的定义和资源的加载应该要有一个清晰地界限； 统一的抽象。统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来界定。 统一资源：Resourceorg.springframework.core.io.Resource 为 Spring 框架所有资源的抽象和访问接口，它继承 org.springframework.core.io.InputStreamSource 接口。作为所有资源的统一抽象，Resource 定义了一些通用的方法，由子类 AbstractResource 提供统一的默认实现。定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public interface Resource extends InputStreamSource { /** * 资源是否存在 */ boolean exists(); /** * 资源是否可读 */ default boolean isReadable() { return true; } /** * 资源所代表的句柄是否被一个 stream 打开了 */ default boolean isOpen() { return false; } /** * 是否为 File */ default boolean isFile() { return false; } /** * 返回资源的 URL 的句柄 */ URL getURL() throws IOException; /** * 返回资源的 URI 的句柄 */ URI getURI() throws IOException; /** * 返回资源的 File 的句柄 */ File getFile() throws IOException; /** * 返回 ReadableByteChannel */ default ReadableByteChannel readableChannel() throws IOException { return java.nio.channels.Channels.newChannel(getInputStream()); } /** * 资源内容的长度 */ long contentLength() throws IOException; /** * 资源最后的修改时间 */ long lastModified() throws IOException; /** * 根据资源的相对路径创建新资源 */ Resource createRelative(String relativePath) throws IOException; /** * 资源的文件名 */ @Nullable String getFilename(); /** * 资源的描述 */ String getDescription();} 子类结构 从类结构图可以看到，Resource 根据资源的不同类型提供不同的具体实现 FileSystemResource：对 java.io.File 类型资源的封装。只要是跟 File 打交道的，基本上与 FileSystemResource 也可以打交道。支持文件和 URL 的形式，实现 WritableResource 接口，且从 Spring Framework 5.0 开始，FileSystemResource 使用 NIO2 API 进行读、写交互。 ByteArrayResource：对字节数组提供的数据的封装。如果通过 InputStream 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 ByteArrayInputStream。 UrlResource：对java.net.URL 类型资源的封装。内部委派 URL 进行具体的资源操作。 ClassPathResource：class path 类型资源的实现。使用给定的 ClassLoader 或者给定的 Class 来加载资源。 InputStreamResource：将给定的 InputStream 作为一种资源的 Resource 的实现类。 AbstractResourceorg.springframework.core.io.AbstractResource，为 Resource 接口的默认抽象实现。它实现了 Resource 接口的大部分的公共实现，作为 Resource 接口中德重中之重，其定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163public abstract class AbstractResource implements Resource { /** * 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流 */ @Override public boolean exists() { try { // 基于 File 进行判断 return getFile().exists(); } catch (IOException ex) { // Fall back to stream existence: can we open the stream? // 基于 InputStream 进行判断 try { InputStream is = getInputStream(); is.close(); return true; } catch (Throwable isEx) { return false; } } } /** * 直接返回true，表示可读 */ @Override public boolean isReadable() { return true; } /** * 直接返回 false，表示未被打开 */ @Override public boolean isOpen() { return false; } /** * 直接返回false，表示不为 File */ @Override public boolean isFile() { return false; } /** * 抛出 FileNotFoundException 异常，交给子类实现 */ @Override public URL getURL() throws IOException { throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL\"); } /** * 基于 getURL() 返回的 URL 构建 URI */ @Override public URI getURI() throws IOException { URL url = getURL(); try { return ResourceUtils.toURI(url); } catch (URISyntaxException ex) { throw new NestedIOException(\"Invalid URI [\" + url + \"]\", ex); } } /** * 抛出 FileNotFoundException 异常，交给子类实现 */ @Override public File getFile() throws IOException { throw new FileNotFoundException(getDescription() + \" cannot be resolved to absolute file path\"); } /** * 根据 getInputStream() 的返回结果构建 ReadableByteChannel */ @Override public ReadableByteChannel readableChannel() throws IOException { return Channels.newChannel(getInputStream()); } /** * 获取资源的长度 * * 这个资源内容长度实际就是资源的字节长度，通过全部读取一遍来判断 */ @Override public long contentLength() throws IOException { InputStream is = getInputStream(); try { long size = 0; byte[] buf = new byte[255]; // 每次最多读取 255 字节 int read; while ((read = is.read(buf)) != -1) { size += read; } return size; } finally { try { is.close(); } catch (IOException ex) { } } } /** * 返回资源最后的修改时间 */ @Override public long lastModified() throws IOException { long lastModified = getFileForLastModifiedCheck().lastModified(); if (lastModified == 0L) { throw new FileNotFoundException(getDescription() + \" cannot be resolved in the file system for resolving its last-modified timestamp\"); } return lastModified; } protected File getFileForLastModifiedCheck() throws IOException { return getFile(); } /** * 抛出 FileNotFoundException 异常，交给子类实现 */ @Override public Resource createRelative(String relativePath) throws IOException { throw new FileNotFoundException(\"Cannot create a relative resource for \" + getDescription()); } /** * 获取资源名称，默认返回 null ，交给子类实现 */ @Override @Nullable public String getFilename() { return null; } /** * 返回资源的描述 */ @Override public String toString() { return getDescription(); } @Override public boolean equals(Object obj) { return (obj == this || (obj instanceof Resource &amp;&amp; ((Resource)obj).getDescription().equals(getDescription()))); } @Override public int hashCode() { return getDescription().hashCode(); }} 如果我们想要实现自定义的Resource，记住不要实现 Resource 接口，而应该继承 AbstractResource 抽象类，然后根据当前的具体资源特性覆盖相应的方法即可。 统一资源定位：ResourceLoader一开始就说了 Spring 将资源的定义和资源的加载区分开了，Resource 定义了统一的资源，那资源的加载则由 ResourceLoader 来统一定义。 org.springframework.core.io.ResourceLoader 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器。其定义如下： ResourceLoader，定义资源加载器，主要应用于根据给定的资源文件地址，返回对应的 Resource。 ——《Spring 源码深度解析》P16 123456789public interface ResourceLoader { String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; // CLASSPATH URL 前缀。默认为：\"classpath:\" Resource getResource(String location); ClassLoader getClassLoader();} getResource(String location) 方法，根据所提供资源的路径 loaction 返回 Resource 实例，但是它不确保该 Resource 一定存在，需要调用 Resource.exist() 方法来判断。 该方法支持以下模式的资源加载： URL 位置资源，如 &quot;file:C:/test.dat&quot;。 ClassPath 位置资源，如 classpath:test.dat。 相对路径资源，如 WEB-INF/test.dat ，此时返回的 Resource 实例，根据实现不同而不同。 该方法的主要实现是在其子类 DefaultResourceLoader 中实现，具体过程我们在分析 DefaultResourceLoader 时做详细说明。 getClassLoader() 方法，返回 ClassLoader 实例，对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用该方法来获取。在分析 Resource 时，提到了一个类 ClassPathResource，这个类是可以根据指定的 ClassLoader 来加载资源的。 子类结构作为 Spring 统一的资源加载器，它提供了统一的抽象，具体的实现则由相应的子类来负责实现，其类的类结构图如下： DefaultResourceLoader与 AbstractResource 相似，org.springframework.core.io.DefaultResourceLoader 是 ResourceLoader 的默认实现。 构造函数它接收 ClassLoader 作为构造函数的参数，或者使用不带参数的构造函数。 在使用不带参数的构造函数时，使用的 ClassLoader 为默认的 ClassLoader （一般 Thread.currentThread()#getContextClassLoader()）。 在使用带参数的构造函数时，可以通过 ClassUtils#getDefaultClassLoader() 获取 代码如下： 1234567891011121314151617181920@Nullableprivate ClassLoader classLoader;public DefaultResourceLoader() { // 无参构造函数 this.classLoader = ClassUtils.getDefaultClassLoader();}public DefaultResourceLoader(@Nullable ClassLoader classLoader) { // 带 ClassLoader 参数的构造函数 this.classLoader = classLoader;}public void setClassLoader(@Nullable ClassLoader classLoader) { this.classLoader = classLoader;}@Override@Nullablepublic ClassLoader getClassLoader() { return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());} 另外，也可以调用 #setClassLoader() 方法进行后续设置。 getResource 方法ResourceLoader 中最核心的方法为 #getResource(String location)，它根据提供的 location 返回相应的 Resource。而 DefaultResourceLoader 对该方法提供了核心实现（因为，它的两个子类都没有提供覆盖该方法，所以可以断定 ResourceLoader 的资源加载策略就封装在 DefaultResourceLoader 中），代码如下： 1234567891011121314151617181920212223242526272829303132// DefaultResourceLoader.java@Overridepublic Resource getResource(String location) { Assert.notNull(location, \"Location must not be null\"); // 首先，通过 ProtocolResolver 来加载资源 for (ProtocolResolver protocolResolver : this.protocolResolvers) { Resource resource = protocolResolver.resolve(location, this); if (resource != null) { return resource; } } // 其次，以 / 开头，返回 ClassPathContextResource 类型的资源 if (location.startsWith(\"/\")) { return getResourceByPath(location); // 再次，以 classpath: 开头，返回 ClassPathResource 类型的资源 } else if (location.startsWith(CLASSPATH_URL_PREFIX)) { return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); // 然后，根据是否为文件 URL ，是则返回 FileUrlResource 类型的资源，否则返回 UrlResource 类型的资源 } else { try { // Try to parse the location as a URL... URL url = new URL(location); return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); } catch (MalformedURLException ex) { // 最后，返回 ClassPathContextResource 类型的资源 // No URL -&gt; resolve as resource path. return getResourceByPath(location); } }} 首先，通过 ProtocolResolver 来加载资源，成功返回 Resource。 其次，若 locaation 以 / 开头，则调用 #getResourceByPath() 方法，构造 ClassPathContextResource 类型资源并返回。代码如下： 123protected Resource getResourceByPath(String path) { return new ClassPathContextResource(path, getClassLoader());} 再次，若 location 以 classpath:开头，则构造 ClassPathResource 类型资源并返回。在构造该资源时，通过 #getClassLoader() 获取当前的 ClassLoader。 然后，构造 URL，尝试通过它进行资源定位，若没有抛出 MalformedURLException 异常，则判断是否为 FileURL，如果是则构造 FileUrlResource 类型，否则构造 UrlResource 类型的资源。 最后，若在加载过程中抛出 MalformedURLException 异常，则委派 #getResourceByPath() 方法，实现资源定位加载。实际上，和「其次」相同。 ProtocolResolverorg.springframework.core.io.ProtocolResolver，用户自定义协议资源解决策略，作为 DefaultResourceLoader 的 SPI：它允许用户自定义资源加载协议，而不需要继承 ResourceLoader 的子类。在介绍 Resource 时，提到如果要实现自定义 Resource，我们只需要继承 AbstractResource 即可，但是有了 ProtocolResolver 后，我们不需要直接继承 DefaultResourceLoader，改为实现 ProtocolResolver 接口也可以实现自定义的 ResourceLoader。 ProtocolResolver 接口，仅有一个方法 Resource resolve(String location, ResourceLoader resourceLoader)。代码如下： 12345678910111213/** * 使用指定的 ResourceLoader ，解析指定的 location 。 * 若成功，则返回对应的 Resource 。 * * Resolve the given location against the given resource loader * if this implementation's protocol matches. * @param location the user-specified resource location 资源路径 * @param resourceLoader the associated resource loader 指定的加载器 ResourceLoader * @return a corresponding {@code Resource} handle if the given location * matches this resolver's protocol, or {@code null} otherwise 返回为相应的 Resource */@NullableResource resolve(String location, ResourceLoader resourceLoader); 在 Spring 中你会发现该接口并没有实现类，它需要用户自定义，自定义的 Resolver 如何加入 Spring 体系呢？调用 DefaultResourceLoader#addProtocolResolver(ProtocolResolver) 方法即可。代码如下： 123456789/** * ProtocolResolver 集合 */private final Set&lt;ProtocolResolver&gt; protocolResolvers = new LinkedHashSet&lt;&gt;(4);public void addProtocolResolver(ProtocolResolver resolver) { Assert.notNull(resolver, \"ProtocolResolver must not be null\"); this.protocolResolvers.add(resolver);} 示例下面示例是演示 DefaultResourceLoader 加载资源的具体策略，代码如下（该示例参考《Spring 揭秘》 P89）： 12345678910111213ResourceLoader resourceLoader = new DefaultResourceLoader();Resource fileResource1 = resourceLoader.getResource(\"D:/Users/von/Documents/spark.txt\");System.out.println(\"fileResource1 is FileSystemResource:\" + (fileResource1 instanceof FileSystemResource));Resource fileResource2 = resourceLoader.getResource(\"/Users/von/Documents/spark.txt\");System.out.println(\"fileResource2 is ClassPathResource:\" + (fileResource2 instanceof ClassPathResource));Resource urlResource1 = resourceLoader.getResource(\"file:/Users/von/Documents/spark.txt\");System.out.println(\"urlResource1 is UrlResource:\" + (urlResource1 instanceof UrlResource));Resource urlResource2 = resourceLoader.getResource(\"http://www.baidu.com\");System.out.println(\"urlResource1 is urlResource:\" + (urlResource2 instanceof UrlResource)); 运行结果： 1234fileResource1 is FileSystemResource:falsefileResource2 is ClassPathResource:trueurlResource1 is UrlResource:trueurlResource1 is urlResource:true 其实对于 fileResource1，我们更加希望是 FileSystemResource 资源类型。但是，事与愿违，它是 ClassPathResource 类型。为什么呢？在 DefaultResourceLoader#getResource() 方法的资源加载策略中，我们知道 D:/Users/von/Documents/spark.txt 地址，其实在该方法中没有相应的资源类型，那么它就会在抛出 MalformedURLException 异常时，通过 DefaultResourceLoader#getResourceByPath(...) 方法，构造一个 ClassPathResource 类型的资源。 而 urlResource1 和 urlResource2，指定有协议前缀的资源路径，则通过 URL 就可以定义，所以返回的都是 UrlResource 类型。 FileSystemResourceLoader从上面的示例，我们看到，其实 DefaultResourceLoader 对 #getResourceByPath(String) 方法处理其实并不是很恰当，这个时候我们可以使用 org.springframework.core.io.FileSystemResourceLoader。它继承 DefaultResourceLoader，且覆写了 #getResourceByPath(String) 方法，使之从文件系统加载资源并以 FileSystemResource 类型返回，这样我们就可以得到想要的资源类型。代码如下： 123456789@Overrideprotected Resource getResourceByPath(String path) { // 截取首 / if (path.startsWith(\"/\")) { path = path.substring(1); } // 创建 FileSystemContextResource 类型的资源 return new FileSystemContextResource(path);} FileSystemContextResourceFileSystemContextResource， 为FileSystemResourceLoader 的内部类，它继承 FileSystemResource 类，实现 ContextResource 接口。代码如下： 123456789101112131415/** * FileSystemResource that explicitly expresses a context-relative path * through implementing the ContextResource interface. */private static class FileSystemContextResource extends FileSystemResource implements ContextResource { public FileSystemContextResource(String path) { super(path); } @Override public String getPathWithinContext() { return getPath(); }} 在构造器中，也是调用 FileSystemResource 的构造函数来构造 FileSystemResource 的。 为什么要有 FileSystemContextResource 类的原因是，实现 ContextResource 接口，并实现对应的 #getPathWithinContext() 接口方法。 示例再回过头看上一节的示例，如果将 DefaultResourceLoader 改为 FileSystemResourceLoader，则 fileResource1 则为 FileSystemResource 类型的资源。 ClassRelativeResourceLoaderorg.springframework.core.io.ClassRelativeResrouceLoader，是 DefaultResourceLoader 的另一个子类的实现。和 FileSystemResourceLoader 类似，在实现代码的结构上类似，也是覆写 #getResourceByPath(String path) 犯法，并返回其对应的 ClassRelativeContextResource 的资源类型。","link":"/2020/08/22/%E3%80%90Spring%E6%BA%90%E7%A0%81%E3%80%91IoC%E4%B9%8BSpring%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5/"},{"title":"在云服务器上安装配置Kafka遇到的问题及解决方案","text":"在学习Kafka，准备在服务器上搭一个使用Kafka的项目。对服务器的使用不是很熟练，在安装使用Kafka的时候遇到了一些问题，记录下来。 服务器情况腾讯云，标准型S2，1核，1GB，1Mbps，操作系统 CentOS 7.6 64位，坐标香港 其实我之前买过阿里云的服务器，但是当时选的服务器位置在境内，由于工信部要求如果要在境内服务器上部署网站需要备案，现在我在香港，就各种不方便。因此另外买了一台香港的服务器，刚好腾讯十周年活动，腾讯云的香港服务器比其他几家大厂都便宜得多，于是选了腾讯云的。但是毕竟是境外的服务器，比境内的还是要贵，所以选的是1核1G的，想了想穷学生学习应该也够，结果就遇上问题了orz Kafka运行内存不足问题在安装好Kafka准备启动的时候，报如下错误 12345678[root@VM-0-6-centos kafka_2.11-2.4.0]# bin/kafka-server-start.sh config/server.properties &amp;[1] 5158[root@VM-0-6-centos kafka_2.11-2.4.0]# Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c0000000, 1073741824, 0) failed; error='Cannot allocate memory' (errno=12)## There is insufficient memory for the Java Runtime Environment to continue.# Native memory allocation (mmap) failed to map 1073741824 bytes for committing reserved memory.# An error report file with more information is saved as:# /opt/install/kafka_2.11-2.4.0/hs_err_pid5158.log 看报错情况应该是内存不足，果然1G还是有点小，但没办法只能修改配置了。 修改启动脚本，Kafka安装目录下：/bin/kafka-server-start.sh 修改 export KAFKA_HEAP_OPTS=&quot;-Xmx1G -Xms1G&quot; 为 export KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms128M&quot; （也可以修改为其它合适的大小） ip地址绑定错误问题启动Kafka的时候报如下错误 kafka.common.KafkaException: Socket server failed to bind to xx:9092: Cannot assign requested address 解决方法参考：https://qii404.me/2018/02/02/kafka-cluster.html 该情况下的虚拟机对外ip（暴露的ip，也就是服务器提供的公网ip）和真实ip（ifconfig显示的ip，也就是服务器提供的内网ip）可能只是映射关系，用户访问对外ip时，OpenStack会转发到对应的真实ip实现访问。但此时如果 server.properties 123listeners=PLAINTEXT://xxx.xxx.xxx.xxx:9092 advertised.listeners=PLAINTEXT://xxx.xxx.xxx.xxx:9092 中的ip配置为（对外ip）的时候无法启动，socket无法绑定监听 解决方法也很简单，将ip改为真实ip（ifconfig中显示的ip，也就是内网ip）即可，其他使用时正常使用对外ip即可，跟真实ip就没有关系了。 上述改完Kafka就能成功启动了，但会出现下一个问题。 Kafka连接服务器出现”Connection to node 1 (localhost/127.0.0.1:9092) could not be established”在Kafka成功启动后，启动项目项目，会报这个错误。 在本地测试的时候安装运行好Kafka后就能成功运行项目了，但是放到服务器上就报错了。从错误信息可以看到，SpringBoot开启后连接的是127.0.0.1，也就是本地的Kafka broker，但是配置文件中配置的是服务器的IP地址。 先来一点点排查错误。 安全组是否开放&amp;防火墙是否拦截请求一般数据库或Redis连接不可用，都有可能是安全组没有开放或者防火墙拦截了外来连接导致。登陆腾讯云服务器管理台后发现，9092端口和2181端口都是开放的，说明腾讯云这边并没有关闭了Kafka和Zookeeper的外部连接权限，那么尝试下端口扫描，发现这两个端口依然可以被外部访问。 登陆服务器查看Kafka broker是否可用12345[root@VM-0-6-centos wechat_template]# lsof -i:9092COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 26077 root 123u IPv6 501530 0t0 TCP VM-0-6-centos:XmlIpcRegSvc (LISTEN)java 26077 root 139u IPv6 501545 0t0 TCP VM-0-6-centos:43702-&gt;VM-0-6-centos:XmlIpcRegSvc (ESTABLISHED)java 26077 root 140u IPv6 501546 0t0 TCP VM-0-6-centos:XmlIpcRegSvc-&gt;VM-0-6-centos:43702 (ESTABLISHED) 通过查询Kafka broker默认端口9092发现，服务运行状态良好，排除掉服务下线的可能性。 查看Kafka运行日志1234567891011[root@VM-0-6-centos kafka_2.11-2.4.0]# tail -f logs/server.log[2020-08-26 14:47:04,804] INFO [TransactionCoordinator id=0] Starting up. (kafka.coordinator.transaction.TransactionCoordinator)[2020-08-26 14:47:04,876] INFO [TransactionCoordinator id=0] Startup complete. (kafka.coordinator.transaction.TransactionCoordinator)[2020-08-26 14:47:04,930] INFO [Transaction Marker Channel Manager 0]: Starting (kafka.coordinator.transaction.TransactionMarkerChannelManager)[2020-08-26 14:47:04,998] INFO [ExpirationReaper-0-AlterAcls]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper)[2020-08-26 14:47:05,046] INFO [/config/changes-event-process-thread]: Starting (kafka.common.ZkNodeChangeNotificationListener$ChangeEventProcessThread)[2020-08-26 14:47:05,093] INFO [SocketServer brokerId=0] Started data-plane processors for 1 acceptors (kafka.network.SocketServer)[2020-08-26 14:47:05,095] INFO Kafka version: 2.4.0 (org.apache.kafka.common.utils.AppInfoParser)[2020-08-26 14:47:05,095] INFO Kafka commitId: 77a89fcf8d7fa018 (org.apache.kafka.common.utils.AppInfoParser)[2020-08-26 14:47:05,095] INFO Kafka startTimeMs: 1598424425093 (org.apache.kafka.common.utils.AppInfoParser)[2020-08-26 14:47:05,096] INFO [KafkaServer id=0] started (kafka.server.KafkaServer) 运行状态良好，没有出现WARN和ERROR信息，从日志看不出问题。 网上找资料没能力找到问题所在，那么问问google，总有一些解决问题的方式，虽然并不一定能直接解决问题，但是在查找问题的过程中还是能学到很多，例如这篇博客也提到了Kafka外网连接问题，但按照这个方式修改后并不能解决我的问题： kafka连接问题 这里面提到了一个很重要的概念： kafka启动后会在zookeeper的/brokers/ids下注册监听协议，包括IP和端口号，客户端连接的时候，会取得这个IP和端口号。后来查看了kafka的配置，原来我忽视了listeners和advertised.listeners的区别，advertised.listeners才是真正暴露给外部使用的连接地址，会写入到zookeeper节点中的。于是再次进行修改，把IP配置到advertised.listeners中，问题再一次解决。 advertised.listeners才是真正的对外代理地址！那么listeners的作用就不是对外提供服务代理，而是监听！ 解决问题修改server.properties的两行默认配置： 1234# 允许外部端口连接 listeners=PLAINTEXT://0.0.0.0:9092 # 外部代理地址（如已修改为真实ip，也就是服务器的内网ip，则不变） advertised.listeners=PLAINTEXT://xxx.xxx.xxx.xxx:9092","link":"/2020/08/26/%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEKafka%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"《Head First设计模式》脑图笔记","text":"读完了《Head First设计模式》，做了个脑图笔记总结输出，使用的是Marginnote 3，由于整本书的脑图太长，一章一章截下来放到笔记里的。 对标记颜色做了分类，红色为标题，黄色为重点，绿色为次重点，蓝色为补充 策略模式 观察者模式 装饰者模式 工厂方法模式 抽象工厂模式 单件模式 命令模式 适配器模式 外观模式 模板方法模式 迭代器模式 组合模式 状态模式 代理模式 复合模式","link":"/2020/07/22/%E3%80%8AHead-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%84%91%E5%9B%BE%E7%AC%94%E8%AE%B0/"},{"title":"CMSC 5728 Decision Analysis &amp; Game Theory - Lecture 01","text":"Lecture 01 Introduction Two-person Zero-sum Games零和博弈 所有博弈方的利益之和为零或一个常数，即一方有所得，其他方必有所失。也可以说：自己的幸福是建立在他人的痛苦之上的，二者的大小完全相等，因而双方都想尽一切办法以实现“损人利己”。零和博弈的例子有赌博、期货和选举等。——维基百科 重点是如果P1赢，就意味着P2输，双方是一种对立关系。比如你和朋友吃一张披萨，你多吃一口，他就少吃一口。 我们拿围棋举例说明。为了简单起见，我们就假定X、Y两人下围棋，该X走下一步棋了，他有3种可选的下法，分别是x1、x2、x3，Y也有三种，分别是y1、y2和y3。 在围棋中，一方的所得必然是另一方所失，因此这是一个零和游戏，比如说X走了x1这步棋后，在盘面上的胜率所得是7点，那么Y的胜率损失也是7点。在这样的情形下，我们只要考虑X的胜率变化即可，因为X赢了多少就是Y输的。 我们知道当X采用了x1、x2、 x3之中的一种策略后，Y也有相应的三种策略y1、y2和y3,因此它们的组合就有9种结果，就构成了一个3x3的矩阵。在每一个组合中， X有一个胜率的变化，这些变化就构成了矩阵的值：(我们假设这9个结果对应了X能获得的9个分数。) 在这个矩阵中，你可以看到，当X采用x1策略时，他最好的情况是碰上Y采用y1，这时X的胜率就增加7点，但是如果Y是一个高手，他采用了y3策略应对，你可以看到X的胜率就小了10点。因此X如果考虑到Y可能的应对策略，他就应该知道，x1其实不能算是一步好棋。 相比之下，采用x2策略就稳健得多，因为无论Y如何应对，他至少可以让自己的胜率增加一点。至于x3，因为有胜率减少一点的可能性，也没有x2好。因此，在制定策略时，如果我们不考虑对方的应对，显然x1是最好的，x2是最差的，但是考虑到对方应对的情况，可能最好和最差的策略就反过来了。 具体到博弈这件事，特别是计算机博弈，最通用的策略是，“在对方给我们造成最糟糕的局面里，选择相对最好的”。也就是说，我们要把x1、x2和x3所有策略算出来后，在可能得到的最糟糕结果中进行比较，具体到这个问题，就是-10、 1和-1这三个结果，然后排序找到最大的，那就是1。在计算机算法中，这种策略被称为最小值中的最大值策略（min-max algorithm）。 接下来我们站在Y的角度来看看他的选择。我们假设他先行棋后，胜率变化的矩阵还是上面那个，当然负值表示他的胜率上升。如果他选择y3，虽然可能让胜率增加10点（对应-10那个值），但是，也冒着损失4点的风险。相比之下，y2的选择就比较好，因为最不济也不过让胜率损失1个点。类似的，可以分析出来y1也不如y2。 回到课件。对P1来说，数值越大得分越高，B的每一列都比C小，则称C ”dominates“ B；对P2来说，数值越大失分越多，B的每一列都比C小，则称B ”dominates“ C。 Saddle Points鞍点然而这种分析方法并不是每次都有用，因为会出现如下的情况。 此时P2没有一列能够”dominates“另一列，因此需要另一种解决方法，鞍点。 Salle Point鞍点：非局部极值点的驻点。——维基百科 此时，对P1来说，鞍点是所有最小值（-1、2、-16）中的最大值；对P2来说，是所有最大值（12、2、3）中的最小值。 在两方的博弈中，大家其实就是在寻找马鞍点这样一个平衡点， 因为大家都知道，如果自己走出了这个平衡点，试图扩大自己的利益，对方就会有反制手段，让自己的利益受损。 当然并非所有的问题里这样的平衡点都在。比如前面那个对弈的胜率矩阵，如果里面的数字都是些很大的正值，也就是说X的实力可以秒杀Y，采用什么策略可能Y都无法应对，这种情况其实不用担心。但是当参与方的水平势均力敌，不相上下时，很多时候寻找最小值中的最大值才是最好的出路，或者说其实双方必然会被锁死在那个平衡点上。 这里需要补充一点的是，我们其实作了一个隐含的假定，就是双方的策略都是透明公开的，即双方都知道对方所有可能的选择，也就是说一切是阳谋，不是阴谋。双方所不知道的，无非是对方最终采取的策略。 其次，双方都足够理性（rantional），能够判断出该采用什么策略。","link":"/2020/09/08/CMSC5728-Decision-Analysis-Game-Theory-Introduction/"},{"title":"CMSC 5713 IT Project Management - Lecture 01","text":"Lecture 01 Introduction 项目生命周期 传统项目主要包括如图所示的四个阶段，其中值得一提的是 ”Lessons learned“，即从每次项目中所学到的东西，比如对类似项目的优化、总结改进等，其体现形式一般是文档。 三个目标 在项目中主要考虑三个目标，scope（规模）、time（时间）、cost（金钱）。这三者是相互关联的，比如当你固定了规模，想降低时间成本，那么你的金钱支出可能会上升，因为你可能需要花钱雇佣别人来干活，那么你就通过花费金钱减少了时间。同样的，当你想降低你的规模，那么你的时间与金钱也会相应降低，因为你不需要那么多的时间与金钱就能完成你的目标。 一个好的 project management，就是能够满足以下两点 满足这三个目标，scope、time与cost 让项目的赞助商满意 Project、Program、Portfolio Program是一组以协作方式进行管理的一组相关 projects，以从单独管理它们中获得收益和控制（？） Protofolio 是 program 或 project 和其他工作的集合，它们组合在一起以促进对该工作的有效管理以实现战略业务目标。 因此 program managers 跟 project managers 的职能也会有所不同，program manager 会同时管理多个近似的 projects，而project manager则相反。 Project Management Project management is “the application of knowledge, skills, tools and techniques to project activities to meet project requirements.” 项目管理是“将知识，技能，工具和技术应用于项目活动中以满足项目要求”。 这里的 skills 分为 soft skill 跟 hard skill，是一个 project manager 需要的技能。 Hard skills 包括产品知识，并知道如何使用各种项目管理工具和技术。 Soft skills 包括能够与各种类型的人一起工作。 Project Stakeholders Stakeholders are the people involved in or affected by project activities. 利益相关者是参与项目活动或受其影响的人员。 Stakeholders 包括： Project sponsor 项目发起人 Project manager 项目经理 Project team 项目团队 Support staff 支持人员 Users 用户 Suppliers 供应商 Opponents to the project 项目的反对人员 Project management framework PM Knowledge Areas 四个核心知识领域导致特定的项目目标（scope，time，cost，quality）。 五个促进 knowledge 的领域是实现项目目标的手段（human resources，communication，stakeholder management，risk and procurement management）。 一个 knowledge 领域（project integration management）会影响所有其他知识领域并受其影响。 所有知识领域都很重要！ PM Tools and Techniques 项目管理工具和技术可在项目管理的各个方面协助项目经理及其团队 特别的工具与技术包括： project charters（项目章程）、scope statement（范围声明）、WBS （scope） Gantt charts （甘特图）、network diagrams（网络图）、critical path analyses（关键路径分析）、criticial chain scheduling（关键链调度）（time） cost estimates（成本估算）、earned value management（挣值管理）（cost） Sample Gantt Chart 甘特图 Work Breakdown Structure (WBS)，工作分解结构，是将一个项目细部分解为交付标的导向的较小组成。工作分解结构是关键的项目交付标的，可将项目团队工作组编成为可管理的部分。项目管理知识体系〈PMBOK第五版〉所定义的工作分解结构：“由项目团队实施整个项目工作范围的阶层化分解，以达成项目目标，并产出必要的交付标的”。 工作分解结构的基本元素，可为资料、服务、产品或其组合，工作分解结构也为细部成本估算与管制提供了必要的框架，以及时程展开与管制的指引。——维基百科 Sample Network Diagram","link":"/2020/09/09/CMSC-5713-IT-Project-Management-Introduction/"},{"title":"CMSC 5724 Data Mining and Knowledge Discovery - Lecture 01","text":"Lecture 01 Classification and Decision Trees Classification 这里的 U 跟 X 一样，是各个 attribute : A1… Ad 的 Cartesian product（笛卡尔乘积），同时也是 instance space（实例空间）；Y 则是 label space（标签空间）。作为 attribute 的 Ai 如下图所示就是 age、education、occupation，他们共同组成了实例空间。而 loan default 就是 label，yes / no 就是 -1 / 1，组成了标签空间。 此时也可以定义 ( instance, label ) - pair（pair有时也叫Object），即 ( x, y ) ∈ X × Y，这里的 x 是向量，即样本空间的一行，如下图所示就是 e.g. age = 28、education = high school、occupation = self-employed。X 跟 Y 的笛卡尔乘积代表了所有的可能性，也就是 D，这在后面会讲到。 其实究其原因，就是我们需要去将这个 D 进行分类，因为 D 的真正分类我们是不知道的，我们就需要通过样本，通过训练集，通过模型，去预测实际的情况。D 也就类似于一个真理，这个真理只有上帝知道，我们能做的就是去通过各种方法找到真理（也有可能只是逼近）。 由于我们只知道向量x，也就是上图中的每一行，为了知道 D，也就是真理，也就是所有的可能性，我们需要 classifier，它通常也叫 hypothesis 或者 concept，定义为 h : X -&gt; Y。它可以理解为一个 function，将 X 中的每一个元素映射到 Y 中，就像是用 Y 的 -1 / 1 给它们打上了标签。这个过程通常是潜藏的（latent），我们看不见的。 根据上述，我们定义 h : classifier，则我们预测 label 的结果是 h(x)。但这是有可能有错误的，我们将预测的错误结果写作 err_D(h)，我们要做的就是尽可能最小化 err_D(h)。 为了更好地预测 D，我们设置了训练集 S。同时我们希望我们生成的 h 的 err_D(h) 尽可能地小。然而这个 err_D(h) 你只能尽可能让它小，你是控制不了的，你能控制的是 err_S(h)，即样本误差。 分子为 objects 的数量，这里的 objects 是一个样本对，即一个样本对应一个标签，它属于样本集 S，同时 s.t.（subject to） 代表受后面的约束，该约束条件为预测的结果跟实际结果不一致，即 h(x) ≠ y。 Q &amp; AQ : “independently” is so important because errS(h) will be close enough to errD(h)? A : related to large number law 老师表示下节课会谈 Q：why could we minimize err_D(h) just given training set? why not err_S(h) A : both of them should be considered, but err_S(h) may be secondary. Q : can we think that D has all the answers we need for (x, y) and that’s why we are trying to get close to it. A : yes, that’s exactly. Decision TreeHunt’s algorithm形式上，我们将决策树 T 定义为完整的二叉树，其中 每个叶节点都带有一个类标签：yes / no 每个内部节点 u : 有两个子节点 有一个 attribute Au 的 predicate —— Pu（也可以理解为一个判断语句） 当 classification 使用决策树 T 时：给定一个 向量x，我们会对每个节点 u 做如下事情 如果 u 是一个叶子节点，返回 u 的 label 如果 向量x 满足 Pu，那么去到左子节点，否则，去到右子节点 我们回到上面那个例子 从根节点开始，遇到的每一个判断条件，即 predicate，走向不同的分叉，最后得到 yes / no。 T ：决策树 u ：T 里的节点 S ：训练集 S(u) 定义： 如果 u 是根节点，那么 S(u) 为 S 假设 S(u) 已经被定义，同时假设 u 是一个有着 v1、v2作为孩子节点的内部节点 S(v1) 定义为满足 S 的对象集 S(v2) 则为 S(u) \\ S(v1)，意为在剩下的子集中查找 我们说S(u) split into S(v1) 和 S(v2) 定义 Pu 的方式决定于 Au 如果 Au 是 ordinal 有序的（学历也可认为是一种有序）：Pu 定义为 Au &gt;= a ∈ dom(Au) 如果 Au 是 nominal 名类的（如职业名称）：Pu 定义为 Au ∈ R ⊆ dom(Au)（R为dom(Au)的子集） Quality of a SplitGini index 基尼系数 其实就是 yes 的百分比与 no 的百分比，当 py = 1，pn = 0 的时候达到 maximum purity，此时 Gini = 0；当 py = 0.5，pn = 0.5时，达到 maximum imputity，此时 Gini = 0.5。Gini 的范围在0到0.5之间。 Principle : the “purer” a set is, the better. 同时，我们定义 split 的基尼系数 选择方法令 P 为全世界的一组人，假设没有其他属性 。 我们想学习一个分类器，给定一个随机的人，可以预测他/她是否喝酒。 为此，我们给定训练集 R⊆P。使用 Hunt’s 算法，我们从 R 中获得决策树 T。很容易看出 T 仅具有一个叶子。 令 c 为该叶子的类值（即c =yes / no）。 然后，对于 P 中的每个对象，我们将其类别值预测为c。 c 的哪个值对 P 有用？ 这应该与P中有多少人属于“yes”类，以及有多少人属于“no”类有关。 具体来说，让 为了使预测 P 中的随机人的错误最小化，如果 πy &gt; πn，则应将 c 设置为 yes，否则将其设置为 no。 举个例子，假设 πy= 0.7 和 πn= 0.3。 然后，如果将 c 设置为yes，我们将有70％的时间是正确的。 另一方面，如果将 c 设置为 no，则只有30％的时间是正确的。 但是，我们不知道 πy 和 πn 的实际值。 因此，我们依靠 R 来猜测这两个值之间的关系。 如果 R 中的 yes 对象多于 no 对象，我们猜 πy&gt;πn，因此将 c 设置为 yes； 否则，我们将 c 设置为 no。 这正是 Hunt’s 算法的作用。 如何确保我们获得良好的猜测？ 显然，我们需要 R 的数量大。 这非常直观：如果没有足够的训练数据，则没有办法建立可靠的决策树。 在这种情况下，训练数据没有统计意义。 OtherRelationship between the error of a classifier h on S and the error of h on D. 将会在后面课程讨论。 另一种问法 Q: Can we somehow prove a connection between err_S(h) and err_D(h)? A: 由于 err_S(h) 是我们可以控制的，如果能够证明这两者之间的关系，那么就可以知道最大的误差，也就可以知道最优的决策树。那么如何证明呢，见下一讲的 Generalization Theorem。","link":"/2020/09/10/CMSC-5724-Data-Mining-and-Knowledge-Discovery-Classification-and-Decision-Trees/"},{"title":"ELCT 5830 Network and Web Programming - Exercises 01","text":"Lecture 01 JavaScript Basics Q1.Let X be a variable that stores a positive integer in which its last digitis not zero. Write a segment of JS code to reverse its digits. e.g. if X = 13579; X should become 97531. 12345678function reverseDigit(x) { let res = 0; while (x != 0) { res = res * 10 + x % 10; x = (x / 10) | 0; } return res;} Q2.Write a segment of JS code to make a DEEP copy of array “fruits” and sort the elements in the cloned arrayby “id” in ascending order. 12345const fruits = [ {id:43, title:'Apple', price:12}, {id:21, title:'Banana', price:5}, {id:13, title:'Orange', price:8}, {id:55, title:'Mango', price:15}, {id:44, title:'Grape', price:10}, {id:6, title:'Peach', price: 14}] 12345678910function deepCopy(obj) { return JSON.parse(JSON.stringify(obj));}function compare(a, b) { return a.id - b.id;}newArr = deepCopy(fruits).sort(compare)console.log(newArr) Q3.Implement a function named “length” that takes one parameter and perform the followings: If the parameter is an array, return its length (# of elements) If the parameter is a string, return its length (# of characters) If the parameter is a number that is neither NaN nor Infinity, return thenumber of digits in its integer portion. (e.g., for -456.99, the integerportion is -456, so return 3) Otherwise, return 0 123456789function length(x) { if (Array.isArray(x) || typeof(x) == \"string\") { return x.length; } else if (!isNaN(x) &amp;&amp; x != Infinity) { return Math.abs(x | 0).toString().length; } else { return 0; }} Q4.Implement a function that takes one parameter and returns true if the parameter is an object containing the following three properties: ‘foo’, ‘bar’, and ‘foo-bar’. Otherwise, the function returns false. Please note that the value of the properties can be undefined. 123456function checkProperty(obj) { if (!obj) { return false; } return obj.hasOwnProperty(\"foo\") &amp;&amp; obj.hasOwnProperty(\"bar\") &amp;&amp; obj.hasOwnProperty(\"foo-bar\");}","link":"/2020/09/12/ELCT-5830-Network-and-Web-Programming-Exercises-01/"},{"title":"CMSC 5728 Decision Analysis &amp; Game Theory - Lecture 02","text":"Lecture 02 Minimax Theorem &amp; Nash’s Theorem &amp; Pareto Optimal Games With no Saddle Points当没有 saddle points，如下图所示 此时就P1和P2就需要做出一些策略，称之为 Mixed Strategies。每个玩家都会分配一定的概率选择某个策略，如下图所示 此时， 当 P1 选择 A 的时候：A = 1/3(4) + 2/3(0) = 4/3 当 P1 选择 B 的时候：B = 1/3(-5) + 2/3(3) = 1/3 显然此时选择 A 的收益会更大一些。但是这只是只考虑 P1 的情况，实际上 P2 的选择也会对 P1 有影响，我们继续看。 P2 设使用 C 策略的概率为 x，使用 D 的概率为 ( 1 - x )。此时， 当 P1 选择 A 的时候：A = x(4) + (1-x)(0) = 4x 当 P1 选择 B 的时候：B = x(-5) + (1-x)(3) = 3 - 8x 4x = 3 - 8x，x = 1/4，P1 的 payoff 为 1。 反过来，P1 也有理性，P1 也会做出一些策略的选择 当 P2 选择 C 的时候：C = x(-4) + (1-x)(5) = 5 - 9x 当 P2 选择 D 的时候：D = x(0) + (1-x)(-3) = -3 + 3x 5 - 9x = -3 + 3x，x = 2/3，P2 的 payoff 为 -1。 Two-person Non-zero Sum Games玩家之间并非一定要对立对抗，也可以互相合作，如下图所示，矩阵中会有两个量，分别代表 P1 跟 P2 的损益。 但是这样会造成一个问题，Zero-sum game 的解决方法就是找 saddle points，但是 Non-zero sum game可能会有如下两种情况 左边这种情况，P1 跟 P2 都找到了对各自利益最大化的点，即（5，4）。但是右边这种情况会形成一个循环，P1 认为对自己利益最大的点 P2 不认可，反之 P1 也不认可。此时就需要一个新的解决方法，Nash’s Theorem Nash’s Theorem 在博弈论中，如果每个参与者都选择了自己的策略，并且没有玩家可以透过改变策略而其他参与者保持不变而获益，那么当前的策略选择的集合及其相应的结果构成了纳什均衡。——维基百科 根据 Nash’s Theorem 得出的游戏结果是一个 NEP（Nash Equilibrium Point纳什均衡点），任何 saddle point 也是 NEP。 The Prisoner’s Dilemma 囚徒困境Nash’s Theorem 著名的例子就是囚徒困境 S 为 Silence 保持沉默，C 为 confess 招供。由图可知，当两人都保持沉默时是对两人都是最好的情况，都只判刑2年。但是双方是不能交流的，如果自己保持沉默，对方招供了，那么对方将仅判1年，而自己将判10年。因此，两个犯人都会为了争取尽可能最小的判刑时间，而都选择招供，这个点就是 NEP。 Paroto Optimal 在没有使任何人境况变坏的前提下，使得至少一个人变得更好，这就是帕雷托改善。帕雷托最优的状态就是不可能再有更多的帕雷托改善的状态；换句话说，不可能在不使任何其他人受损的情况下再改善某些人的境况。 需要指出的是，帕雷托最优只是各种理想态标准中的“最低标准”。也就是说，一种状态如果尚未达到帕雷托最优，那么它一定是不理想的，因为还存在改进的余地，可以在不损害任何人的前提下使某一些人的福利得到提高。但是一种达到了帕雷托最优的状态并不一定真的很“理想”。——维基百科 如上图所示，（2，2）、（10，1）、（1，10）都是 Paroto Optimal。 Cournot Model of Duopoly古诺寡头竞争的假设 两个寡头厂商生产的产品是同质或无差别的； 每个厂商都根据对手的策略采取行动，并假定对手会继续这样做，据此来做出自己的决策； 为方便起见，假定每个厂商的边际成本为常数，并假设每个厂商的需求函数是线形的； 两个厂商都通过调整产量来实现各自利润的最大化； 两个厂商不存在任何正式的或非正式的串谋行为。 边际成本亦作增量成本，指的是每增产一单位的产品所造成的总成本的增量。 这个概念表明每一单位的产品的成本与总产品量有关。比如，仅生产一辆汽车的成本是极其巨大的，而生产第101辆汽车的成本就低得多，而生产第10000汽车的成本就更低了。 但是，考虑到机会成本，随着生产量的增加，边际成本可能会增加。——维基百科 博弈分析设 q1、q2 分别代表 企业1 和 企业2 生产的同质产品的产量，市场中该产品的总供给 Q = q1 + q2，令 P(Q) = a - Q 表示市场出清时的价格（假设这只是个简单的市场，固定需要 a 数量的产品） 设 企业i 生产 qi 的总成本 Ci(qi) = cqi，即企业不存在固定成本，且生产每单位产品的边际成本为常数 c （假设 c &lt; a）。 两个企业同时进行产量决策。假定产品是连续可分割的，由于产出不可能为负，因此，每一企业的战略空间可表示为 Si = [0, 无穷]，其中一个代表性战略 si 就是企业选择的产量 qi （qi ≥ 0）。假定企业的收益是其利润额 U。 Ui(q, Q) = qi(a - Q) - cqi = qi[a - (q1 + q2) - c] 为了找到 NEP，企业1 会采取解决方案 企业2 会采取解决方案 则企业i 最优化问题的一阶条件是 也即是，若产量组合 (q1, q2) 为纳什均衡，则企业的产量选择必须满足 联立，得 总结","link":"/2020/09/15/CMSC-5728-Decision-Analysis-Game-Theory-Lecture-02/"},{"title":"CMSC 5713 IT Project Management - Lecture 02","text":"Lecture 01 Project Management Framework Project Management Framework Understand the organization. Involve the users. Manage the processes – PMBOK vs. PRINCE2 Understand the organization 项目不能孤立运行。 项目必须在广泛的组织环境中运作。 项目经理需要运用系统思维（system thinking）： 全面了解项目并了解其与大型组织的关系。 高级经理必须确保项目继续支持当前的业务需求（business needs） Strategy frame Strategy 是旨在实现特定目标的长期行动计划 Strategy 的组成 Strategy vs Tactics 战略与战术 “没有战术的战略是获得胜利的最慢途径。 没有策略的战术就是失败之前的喧嚣。” （中国军事家孙子） 战略定义了你的长期目标以及实现目标的计划。 战略为你提供了实现组织使命所需的途径。 战术要具体得多，而且通常会朝着较小的步骤和较短的时间范围发展。 它们涉及最佳做法，特定计划，资源等。它们也称为“倡议（initiatives）” Organization structure 组织结构是正式的决策框架，工作任务通过该框架进行划分，分组和协调。 组织结构图显示组织结构并显示职务，职权范围以及部门之间的关系 三个基本的组织结构 Functional 职能 将相似或相关的职业专业或过程归为财务，制造，营销等领域的熟悉标题。 Project 项目 or Divisional 部门 由独立生产的战略业务部门组成，每个部门均生产单个产品 。 Matrix 矩阵 职能结构与项目结构之间的中间立场 Origanization structure influences on projects 项目经理需要了解组织结构。 原因 组织结构会极大地影响他们的作用。 确定他们需要从哪些职能中获得哪些技能 Human Resources Frame 人力资源处理组织中管理人员的各个方面，其中包括： 选择 薪酬体系 培训和发展 绩效评估 公司轮换 项目经理需要知道他们在跟谁工作 有助于选择团队成员。 有助于了解如何激励他们的团队。 Q &amp; AQ: What does “walls : can lack customer orientation” means in P.13? A: Means that due to lack of interaction between depts, engineering may simply develop the products without understanding the needs from marketing (who may have better understanding of the customers) Q: What does “silos : create longer decisions cycles” means in P.13? A: Means that decisions need to go through senior executive levels rather than simply at managerial levels (e.g. project manager level) Q: Why project manager need to understand the organizational culture? A: So they can make up what lackings in organization culture within the team, e.g. if the organization has no strong member identify, may be project manager can encourage team to be proud to be part of the team Q: What does “means-ends orientation” means in P.22? A: Means-end orientation describes how much an organization focuses on processes versus end results Q: What does “open-systems focus” means in P.22? A: Open-systems focus describes how aware and reactive your business is to changes outsideyour corporate environment Q: What is the difference between “development” and “implementation” in project lifecycle in P.31? A: Development may include analysis, design and getting details of the concept, implementation including buidling and testing Q: What does “exception” means in “manage by exception” in P.56? A: manage by exception is making decision to fix things when it is not according to plan Q: In “tailor to suit the project environment”, what does “project environment” means? any examples? A: Project environment including the size, how the project fits into company strategy, the important of the project, the organization culture, etc. Q: Does “largely descriptive” in P.61 means “not necessary strictly follow”? And “highly prescriptive” means “must strictly follow”? A: Largely descriptive means at high level, e.g. you just need to take medicine to get better, highly prescriptive means at specific levels, e.g. you need to take this medicine 1 tablet 3 times a day. They both ask you to follow the best practice/advice. Q: What does “directing a project” means in P.58? A: Directing project means making overall decision about the project and exercising overall control. So, it is the duty of project board. While the day-to-day running of the project will be managed by PM.","link":"/2020/09/16/CMSC-5713-IT-Project-Management-Lecture-02/"},{"title":"CMSC 5724 Data Mining and Knowledge Discovery - Lecture 02","text":"Lecture 02 Generalization Theorem &amp; Bayesian Classification Generalization Theorem 假设决策树 h 使用 b 个 bits 来表达（因为别人不知道你的决策树是如何编码的，所以必须根据要满足的某些编码约定来表示它，编码方案说明了你的所有约定，以便其他任何人都可以查看该方案并跟你完全相同的方式对任何 h 进行编码，b 取决于你的编码方式，可以看做是上界的长度，可以取任意数字，但是不能是无限数字，因为这样机器无法输出） 我们给定一个概率大小为0到1之间的值 δ，比如是 0.1%（失败），那么它至少以 (1 - δ) = 99.9%（成功）的概率保持以下的不等式： 这里的err_D(h) 即 generalization error 是我需要去约束的，我们使用能够控制的 err_S(h) 来约束。显然，D 的总量是比 S 要大的，因为 D 代表的是实际、是全部，S 只是我们找的训练集，因此要做好训练集不够完整的准备，有可能约束不了 err_D(h)，需要加第二项来弥补缺少的信息。 假设 err_S(h) 为0，b 为 2 × 10的6次方，S 为 10的6次方，显然这个训练集 S 太小，会导致后面加的值大于 1，然而 Generalization Theorem 不应该大于1（？）。 如果要使用很大数量的 b 也可以，前提是你的 S 要足够大，如下例 通过选择对的决策树，与足够大的 S，会有很小的 err_S(h)，那么你也保证了非常好的 err_D(h)，这就是你该如何运用 Generalization Theorem。 就如同图里的分类器也就是绿色线圈住的部分，是正确的”1“，其余是”-1“，可以看出这个分类器很复杂，你能做的就是通过大量的数据集，去尽可能贴近这个分类器，描述它的轮廓，你不可能完美的复现这个分类器，你能做的就是尽可能减少你的划分的红方框与绿色线的距离，也就是误差。 Proof of the Generalization TheoremHoeffding Bounds p 是我们想要估计得值，Xi 为独立的随机值，可能是1或0，我们设 t 为 Xi 的和，t 可以表达有多少 X 是1，那么 t/n 就是 p 的估计值。我们令 t/n &gt; p + ε，这里的 ε 就需要是很小的值，因为如果很大的话 t/n 会更大。但是如果 ε 很小的话，n 就会非常大。这意味着如果你想要保证只有 1% 的误差，那么你可能需要 10000 的样本。 Hoeffding Bounds 的用途就是，你需要多少的样本来保证你的准确率，它会给你的训练集一个上限值。 Union Bound 比如 A 的概率是 1%，B 的概率是 2%，那么 A 并 B 的概率会小于等于三，因为可能它们会有交集。 Proof令 H 作为可以被 b 个 bits 描述的分类器的集合，H ≤ 2的b次方。给定任意一个分类器 h ∈ H，设 S 为 O1, O2, …, On 训练集，并且 n = S。对于每一个 i ∈ [i, n] 的 Oi，定义 Xi = 1为误分类，那么 err_S(h) = 1/n ∑ Xi。 同时，因为每个 S 里的 object 都是独立地取自 D，那么对于每一个 i ∈ [1, n]， Pr[Xi = 1] = err_D(h)。 通过 Hoeffding bounds，我们可以得到 Pr[err_S(h) &lt; err_D(h) - ε] ≤ e^(-2na^2) 此时，我们要让右边尽可能小， 这里的 0.001 就是之前 Generalization Theorem 提到的 δ，至于为什么是这个形式先往下看。因为我们主要控制将这个不等式中的 ε，因此我们将 ε 抽出来，如下图。 总的来说，就是要通过 err_S(h) 来限定 err_D(h)，但是我们是有可能失败的，失败来自于 反过来说，h 发生失败的时候为当 这里是 ＞，因此我们说它错了。同时我们可以说它发生的概率 ≤ 0.001/2^b。我们可以通过 Union bounds 证明。举个例子，假设老师对每一个同学说你挂科的几率最多为 0.1%/人数总和，那么任意一个学生挂科的概率就为 0.1%，也就是 99.9% 的可能性没有人挂科。回到刚刚的不等式 当不等式左边发生的时候，就是错误发生的时候，我们要让他尽可能小，因此我们就要选择适合的 ε 来达到目的。 Q &amp; AQ: Is number of attribute relevant to err_D(h)? A: Yes and no. No 的原因是在 Generalization Theorem 里看不到 attribute，Yes 是因为它会间接影响 b Q：We choose the number 0.001/(2^b) because if Pr(h fails) &lt;= 0.001/(2^b) &lt;= 0.001/|H| then Pr(none from H fails) &gt;= 0.999 A：exactly Q：Could you show how union bound conclude number δ/2b（这个问题本身是错的） A：","link":"/2020/09/17/CMSC-5724-Data-Mining-and-Knowledge-Discovery-Lecture-02/"}],"tags":[{"name":"Homebrew","slug":"Homebrew","link":"/tags/Homebrew/"},{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"服务器","slug":"服务器","link":"/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"决策论与博弈论","slug":"决策论与博弈论","link":"/tags/%E5%86%B3%E7%AD%96%E8%AE%BA%E4%B8%8E%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"项目管理","slug":"项目管理","link":"/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"数据挖掘与知识发现","slug":"数据挖掘与知识发现","link":"/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%8F%91%E7%8E%B0/"},{"name":"网络与网页编程","slug":"网络与网页编程","link":"/tags/%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/"}],"categories":[{"name":"工具安装及配置","slug":"工具安装及配置","link":"/categories/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"命令","slug":"命令","link":"/categories/%E5%91%BD%E4%BB%A4/"},{"name":"工具使用问题与解决方案","slug":"工具使用问题与解决方案","link":"/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"源码","slug":"源码","link":"/categories/%E6%BA%90%E7%A0%81/"},{"name":"黑科技","slug":"黑科技","link":"/categories/%E9%BB%91%E7%A7%91%E6%8A%80/"},{"name":"课程笔记","slug":"课程笔记","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}]}