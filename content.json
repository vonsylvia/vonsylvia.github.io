{"pages":[],"posts":[{"title":"安装Homebrew遇到connection refused问题解决及Proxifier配置","text":"问题描述刚刚从window转为macOS，很多东西需要重新配置以及熟悉。听说Homebrew是个强大的包管理器，所以用来试试看。在Homebrew官网主页复制了安装命令在终端运行时遇到了connection refused问题 问题解决由于我在境内，需要使用VPN连接，因此我使用的是V2rayU这款开源软件（github地址：https://github.com/yanue/V2rayU），查阅了用户手册后，在代理模式部分看到 全局模式: 有别于vpn,只是将代理信息更新到系统代理http,https,socks,若需要真正全局模式, 推荐搭配使用Proxifier 因此需要Proxifier搭配才能进行全局代理。 添加代理信息安装好Proxifier后还需要进行配置，打开软件，添加代理信息，选择：菜单栏–&gt;&gt;Profile–&gt;&gt;Proxy Servers。 选择add添加服务器，地址填127.0.0.1，端口一般为1080 配置完成在终端即可实现全局代理 远程DNS设置为了防止DNS污染，一般使用代理的时候都会使用远程服务器的DNS设置，具体设置方法是，菜单栏–&gt;&gt;Profile–&gt;&gt;Name Resolution。 然后选择“Resolve hostnames through proxy”即可。（一开始这个选项可能是灰色不能点，将默认的“Detect DNS seetings automatically”点掉即可） 至此，再次尝试在终端安装Homebrew即可。","link":"/2020/06/10/%E5%AE%89%E8%A3%85Homebrew%E9%81%87%E5%88%B0connection-refused%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8F%8AProxifier%E9%85%8D%E7%BD%AE/"},{"title":"MacOS下编译RedisDesktopManagement报no file at...&#x2F;Python.framework&#x2F;...错解决方案","text":"问题描述执行命令：/Users/zzq/Qt5.9.8/5.9.8/clang_64/bin/macdeployqt rdm.app -qmldir=../../../src/qml 出错：ERROR: no file at &quot;/usr/local/opt/python/lib/Python.framework/Versions/3.7/Python&quot; 解决方案该问题是找不到Python.framework，如果你跟笔者一样是用brew安装的，那么就将/usr/local/Cellar/python/3.7.5/Frameworks下的Python.framework文件复制一份到/usr/local/Cellar/python/3.7.5/lib下就行了，我的是3.7.5版本，安装的自己到相应路径下操作即可","link":"/2020/06/29/MacOS%E4%B8%8B%E7%BC%96%E8%AF%91RedisDesktopManagement%E6%8A%A5no-file-at-Python-framework-%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"Homebrew安装指定版本Mysql（以5.7为例）","text":"安装HomebrewHomebrew官网：https://brew.sh/安装途中可能遇到connection refused 问题，可看本人之前发的教程解决 搜索可安装版本$ brew search boost 修改环境变量brew安装的东西都是在 /usr/local/Cellar/ 本人的路径是： /usr/local/Cellar/mysql@5.7/5.7.23/bin mysql版本不同，路径会有一些不同 终端输入命令sudo vim .bash_profile 按i进入insert模式，输入：export PATH=$PATH:/usr/local/Cellar/mysql@5.7/5.7.23/bin 然后esc退出insert模式，并在最下方输入:wq保存退出。（注意“wq”前有个“:”） 生效配置文件source .bash_profile 回车执行，运行环境变量。 自动生效配置文件如果没有这一步，那么每次关掉终端在打开都需要重新source .bash_profile。首先， vi ~/.zshrc 输入： export PATH=${PATH}:/usr/local/Cellar/mysql@5.7/5.7.23/bin 保存后 source ~/.zshrc","link":"/2020/07/18/Homebrew%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%ACMysql%EF%BC%88%E4%BB%A55-7%E4%B8%BA%E4%BE%8B%EF%BC%89/"},{"title":"Homebrew安装Docker Desktop for Mac及MacOS10.15版本的镜像配置方法","text":"搜索Docker的包brew search docker 12345678910111213141516==&gt; Formulaedocker docker-machine-driver-vmwaredocker-clean docker-machine-driver-vultrdocker-completion docker-machine-driver-xhyvedocker-compose docker-machine-nfsdocker-compose-completion docker-machine-parallelsdocker-credential-helper docker-slimdocker-credential-helper-ecr docker-squashdocker-gen docker-swarmdocker-ls docker2acidocker-machine dockerizedocker-machine-completion lazydockerdocker-machine-driver-hyperkit==&gt; Casksdocker-edge homebrew/cask/docker-toolboxhomebrew/cask/docker Casks下的才是Docker Desktop可以使用命令查看信息 brew cask info docker 12345678910111213141516171819==&gt; Tapping homebrew/caskCloning into '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask'...remote: Enumerating objects: 2, done.remote: Counting objects: 100% (2/2), done.remote: Compressing objects: 100% (2/2), done.remote: Total 452026 (delta 0), reused 0 (delta 0), pack-reused 452024Receiving objects: 100% (452026/452026), 205.09 MiB | 5.08 MiB/s, done.Resolving deltas: 100% (320412/320412), done.Tapped 1 command and 3619 casks (3,736 files, 219.9MB).docker: 2.3.0.3,45519 (auto_updates)https://www.docker.com/community-editionNot installedFrom: https://github.com/Homebrew/homebrew-cask/blob/HEAD/Casks/docker.rb==&gt; NamesDocker DesktopDocker Community EditionDocker CE==&gt; ArtifactsDocker.app (App) 安装Dockerbrew cask install docker 123456==&gt; Downloading https://desktop.docker.com/mac/stable/45519/Docker.dmg######################################################################## 100.0%==&gt; Verifying SHA-256 checksum for Cask 'docker'.==&gt; Installing Cask docker==&gt; Moving App 'Docker.app' to '/Applications/Docker.app'.🍺 docker was successfully installed! 安装完成，现在可以从启动台里找到Docker.app了，打开后会在顶部菜单栏里出现 docker logo，并且会弹出登陆界面，登陆后就能正常使用Docker Desktop for Mac了。 # 获取阿里云镜像地址 前往 [阿里云官网](https://www.aliyun.com/?spm=5176.10695662.amxosvpfn.2.26766339P4o7tB) 使用淘宝/支付宝/注册登录，进入控制台 搜索容器镜像服务 获取镜像地址 配置Docker点击小齿轮图形进入设置页面，在Docker Engine配置镜像地址 修改括号内的内容即可：&quot;registry-mirrors&quot;: [ &quot;https://********.mirror.aliyuncs.com&quot; ] 运行Docker在终端输入 docker run hello-world 12Hello from Docker!This message shows that your installation appears to be working correctly.","link":"/2020/07/18/Homebrew%E5%AE%89%E8%A3%85Docker-Desktop-for-Mac%E5%8F%8AMacOS10-15%E7%89%88%E6%9C%AC%E7%9A%84%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"title":"Eight rounding modes八种舍入模式解析","text":"读《Effective Java》Item 60 : Avoid float and double if exact answers are required的时候，结尾写BigDecimal的优点时写道 Using BigDecimal has the added advantage that it gives you full control over rounding, letting you select from eight rounding modes whenever an operation that entails rounding is performed. 这里的eight rounding modes（八种舍入模式）第一次看到，查找资料记录一下 ROUND_UP舍入远离零的舍入模式。在丢弃非零部分之前始终增加数字（始终对非零舍弃部分前面的数字加1）。即，有小数位的情况下，去掉小数位，正数+1，负数-1 ROUND_DOWN接近零的舍入模式。在丢弃某部分之前始终不增加数字（从不对舍弃部分前面的数字加1，即截短）。即，有小数位的情况下，去掉小数位，整数位不变 ROUND_CEILING接近正无穷大的舍入模式。如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同；如果为负，则舍入行为与 ROUND_DOWN 相同。即，有小数位的情况下，去掉小数位，正数+1，负数不变! ROUND_FLOOR接近负无穷大的舍入模式。如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同；如果为负，则舍入行为与 ROUND_UP 相同。即，有小数位的情况下，去掉小数位，正数不变，负数-1 ROUND_HALF_UP向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分 &gt;= 0.5，则舍入行为与 ROUND_UP 相同；否则舍入行为与 ROUND_DOWN 相同。即，四舍五入 ROUND_HALF_DOWN向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。如果舍弃部分 &gt; 0.5，则舍入行为与 ROUND_UP 相同；否则舍入行为与 ROUND_DOWN 相同。即，五舍六入 ROUND_HALF_EVEN向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同；如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况。如果前一位为奇数，则入位，否则舍去。以下例子为保留小数点1位，那么这种舍入方式下的结果。1.15&gt;1.2 1.25&gt;1.2 ROUND_UNNECESSARY断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。 参考http://www.blogjava.net/wangzc2001/archive/2010/12/17/340988.html","link":"/2020/07/23/Eight-rounding-modes%E5%85%AB%E7%A7%8D%E8%88%8D%E5%85%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90/"},{"title":"Homebrew常用命令","text":"本文为Homebrew的常用命令，便于日常操作 常用命令12345678910brew help 查看帮助brew install &lt;package name&gt; 安装软件包brew uninstall &lt;package name&gt; 卸载软件包brew list [--versions] 列出已安装的软件包(包括版本)brew search &lt;package name&gt; 查找软件包brew info &lt;package name&gt; 查看软件包信息brew update 更新brewbrew outdated 列出过时的软件包（已安装但不是最新版本）brew upgrade [&lt;package name&gt;] 更新过时的软件包（不指定软件包表示更新全部）brew doctor 检查brew运行状态 常用软件1234567brew install wgetbrew install curlbrew install opensslbrew install fish #安装fish shellbrew install git-flow #安装git-flowbrew install python #安装python Homebrew-CaskHomebrew-Cask 是 Homebrew 的一个扩展。它能够优雅、简单、快速的安装和管理 macOS 图形界面程序，比如Google Chrome 和Dropbox等等。官网 https://caskroom.github.io/。 Cask 必装的理由有图形界面的软件可以直接在 App Stroe 中下载更新，为啥还需要 Cask 呢？因为有的很好用的免费 Mac 软件并没有选择在 App Store 上架，对于没有上架的软件我们只能是通过搜索找到官网然后在下载安装包，这样不够优雅也不方便管理，而使用 Cask 可以通过一行命令就搞定安装了，还可以统一更新升级所有的软件，实现从非 App Store 途径安装的软件的统一管理。Cask 从软件官方网站下载软件包，然后在后台安装并将 .app 移动到 Applications。通过 Cask 安装的软件也会在 Lanuchpad 显示，跟从 App Store 安装的软件没啥区别。对于那些收费的软件，用 Cask 安装只是比普通安装方法节省了时间和步骤，没啥其他的区别。 Cask 常用命令123456brew cask -help 查看帮助brew cask install &lt;software name&gt; 安装软件brew cask uninstall &lt;software name&gt; 卸载软件brew cask search &lt;software name&gt; 搜索软件brew cask info &lt;software name&gt; 查看软件相关信息brew cask list 列出通过 Homebrew-Cask 安装的包 经过测试，虽然 -help 是未知命令，但是仍然可查看 Cask 的命令，其他帮助命令（如 brew cask -h 和 brew cask –help）好像都不行。还有其他的命令就不一一介绍了，其他命令可以通过brew cask -help查看。 Cask 常用软件12345678910111213141516brew cask install iterm2 #安装iTerm 2brew cask install launchrocket #管理软件后台服务brew cask install google-chrome #安装Chromebrew cask install the-unarchiver #解压软件brew cask install alfred #效率软件brew cask install qq #腾讯QQbrew cask install evernote #云笔记软件brew cask install sublime-text #文本编辑器brew cask install skitch #ervernote配套的截图软件brew cask install dropbox #文件同步软件brew cask install zotero #网页收藏与文献管理软件brew cask install anki #记忆软件brew cask install virtualbox #虚拟机，可以装个Windowsbrew cask install self-control #避免分心的软件brew cask install vlc #视频软件brew cask install appcleaner #应用清理 Quick Look 系列12345brew cask install qlcolorcode #预览脚本时自动代码配色brew cask install qlstephen #预览未知拓展名的纯文本文件brew cask install qlmarkdown #预览Markdown文件brew cask install quicklook-json #预览JSON文件brew cask install quicklook-csv #预览CSV文件 Homebrew-Cask 是一个开源项目，其详细信息可以看其开源项目介绍，所支持的软件列表在这里：https://github.com/caskroom/homebrew-cask/tree/master/Casks 。如果觉得管理软件在后台运行的服务很麻烦，可以装个LaunchRocket，这也是个开源项目。关于 Quick Look 的介绍可以看这篇文章加强你的「一指禅」：Mac QuickLook「快速预览」兼容性扩展教程，同时Quick Look plugins这个开源项目列出了所有支持 Homebrew-Cask 的 Quick Look 扩展，据说支持的都是程序员必备。 轻松实现一键装机在使用 Mac 的过程中，总想着有没有方便、简单的办法实现在不同Mac 上同步开发环境的办法，今天在整理 Homebrew 使用笔记的时候突然冒出一个想法，如果我把所有的 Homebrew 安装命令列成一个清单形式，当在另一台新的 Mac 上工作时，那么就可以先装一个 Homebrew 然后将命令清单中的所有命令复制粘贴到终端中，等待命令执行完毕后，新的 Mac 的大部分开发环境就跟常用的 Mac 开发环境一致了。下面列出笔者的常用命令清单： 12345678910#安装 Homebrew/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"#安装基础套件brew install fish #安装fish shellbrew install git-flow #安装git-flowbrew install python #安装python#Homebrew-Caskbrew tap caskroom/cask 安装Cask基础软件12345678brew cask install iterm2 #安装iTerm 2brew cask install visual-studio-code#微软出品的文本编辑器，可替代 Sublime Textbrew cask install google-chrome #安装Chromebrew cask install the-unarchiver #解压软件brew cask install alfred #效率软件brew cask install qq #腾讯QQbrew cask install sourcetree #Git GUI 客户端brew cask install cheatsheet # 显示当前程序的快捷键列表，默认的快捷键是长按⌘ 参考https://www.cnblogs.com/javalouvre/p/10618340.html","link":"/2020/07/19/Homebrew%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"MacOS下安装JDK并配置路径以解决Homebrew安装Maven后的Java路径不匹配问题","text":"本文记录首次安装JDK及解决Maven路径不匹配问题 安装JDK前往 Oracle官网选择对应版本下载，安装时一路Next即可 验证JDK在终端输入java -version 123java version \"1.8.0_261\"Java(TM) SE Runtime Environment (build 1.8.0_261-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode) 表示已经安装成功，也能正常使用，但此时是没有配置路径的 Homebrew安装的maven中路径与系统Java路径不匹配 Homebrew安装maven方法可参考本人之前的安装mysql的文章 使用Homebrew安装好maven后，在终端输入mvn -v 12345Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)Maven home: /usr/local/Cellar/maven@3.5/3.5.4_1/libexecJava version: 14.0.1, vendor: N/A, runtime: /usr/local/Cellar/openjdk/14.0.1/libexec/openjdk.jdk/Contents/HomeDefault locale: zh_CN_#Hans, platform encoding: UTF-8OS name: \"mac os x\", version: \"10.15.4\", arch: \"x86_64\", family: \"mac\" 可以看到，这里的Java版本是14.0.1，这是因为使用Homebrew安装maven的时候会一并安装最新版本的OpenJDK。因此需要我们手动配置一下。 配置Java路径 参考来源：https://www.jianshu.com/p/6831bfb8e012 在终端输入sudo vim /etc/profile按i进入insert模式，在下方加入四行配置 1234JAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home\"export JAVA_HOMECLASS_PATH=\"$JAVA_HOME/lib\"PATH=\".$PATH:$JAVA_HOME/bin\" 输入:wq!保存并退出 1JAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home\" 此处的路径可以去资源库查找自己的路径，也可以打开一个新的终端输入 /usr/libexec/java_home 然后把出现的路径复制过来就行完成上面内容后继续在终端输入 source /etc/profile 回车后即完成配置。 验证配置是否成功终端输入 echo $JAVA_HOME 出现Java路径即成功！ 配置完成后再查看maven，可发现Java已显示为自己安装的1.8版本 12345Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)Maven home: /usr/local/Cellar/maven@3.5/3.5.4_1/libexecJava version: 1.8.0_261, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: \"mac os x\", version: \"10.15.4\", arch: \"x86_64\", family: \"mac\"","link":"/2020/07/21/MacOS%E4%B8%8B%E5%AE%89%E8%A3%85JDK%E5%B9%B6%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84%E4%BB%A5%E8%A7%A3%E5%86%B3Homebrew%E5%AE%89%E8%A3%85Maven%E5%90%8E%E7%9A%84Java%E8%B7%AF%E5%BE%84%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"},{"title":"Mac使用Marginnote3时，启动会自动打开固定某一个笔记解决方案","text":"本文记录使用Marginnote3时，第一次启动会固定打开某一个笔记本的解决方案 这个问题是笔记本链接的问题 打开 12~/Library/Containers/QReader.MarginStudyMac/Data/Library/Preferences~/Library/Containers/QReader.MarginStudyMac/Data/Library/SyncedPreferences 这两个目录下， 删掉“QReader.MarginStudyMac.plist”这个文件。 打开云同步再同步一遍笔记即可。","link":"/2020/07/22/Mac%E4%BD%BF%E7%94%A8Marginnote3%E6%97%B6%EF%BC%8C%E5%90%AF%E5%8A%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E5%9B%BA%E5%AE%9A%E6%9F%90%E4%B8%80%E4%B8%AA%E7%AC%94%E8%AE%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"MySQL基础语法","text":"读《MySQL必知必会》学习MySQL基础语法，记录一下 USE 使用crashcourse数据库 1USE crashcourse; USE语句不返回任何结果。 SHOW 显示数据库名 1SHOW DATABASES; 显示当前选择的数据库内可用表的列表 1SHOW TABLES; 给出表名，对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（如字段cust_id的auto_increment） 1SHOW COLUMNS FROM customers; NOTE：自动增量auto_increment 某些表列需要唯一值。 在每个行添加到表中时， MySQL可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样做必须记住最后一次使用的值） 。如果需要它，则必须在用CREATE语句创建表时把它作为表定义的组成部分。 其他SHOW语句： SHOW STATUS，用于显示广泛的服务器状态信息； SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句； SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限； SHOW ERRORS和SHOW WARNINGS， 用来显示服务器错误或警告消息。 SELECT 用SELECT语句从products表中检索一个名为prod_name的列 （如果没有明确排序查询结果 ，则返回的数据的顺序没有特殊意义 ） 12SELECT prod_nameFROM products; 从products表中选择3列 12SELECT prod_id, prod_name, prod_priceFROM products; 检索所有列 12SELECT *FROM products; 检索不同的行，只返回不同的vend_id行 12SELECT DISTINCT vend_idFROM products; LIMIT 限制结果。使用LIMIT 5返回不多于5行 123SELECT prod_nameFROM productsLIMIT 5; NOTE：LIMIT 为得出下一个5行，可以指定开始行和行数，如LIMIT 5,5，表示从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数。 行0：检索出来的第一行为行0而不是行1。因此， LIMIT 1, 1将检索出第二行而不是第一行。 在行数不够时 ，MySQL将只返回它能返回的那么多行 使用完全限定的表名 12SELECT products.prod_nameFROM crashcourse.products; ORDER BY 使用ORDER BY子句取一个或多个列的名字，据此对输出进行排序 123SELECT prod_nameFROM productsORDER BY prod_name; 按多个列排序。检索3个列，并按其中两个列对结果进行排序，首先按价格，然后再按名称排序 123SELECT prod_id, prod_price, prod_nameFROM productsORDER BY prod_price, prod_name; 按降序排序。 123SELECT prod_id, prod_price, prod_nameFROM productsORDER BY prod_price DESC; 使用ORDER BY和LIMIT组合，prod_price DESC保证行由最贵到最便宜检索，LIMIT 1告诉MySQL仅返回一行 1234SELECT prod_priceFROM productsORDER BY prod_price DESCLIMIT 1; NOTE：ORDER BY子句的位置 在给出ORDER BY子句时，应该保证它位于FROM子句之后。如果使用LIMIT，它必须位于ORDER BY之后。 WHERE 在SELECT语句中，数据根据WHERE子句指定的搜索条件进行过滤。 123SELECT prod_name, prod_priceFROM productsWHERE prod_price = 2.50; NOTE： SQL过滤与应用过滤。数据也可以在应用层过滤。为此目的， SQL的SELECT语句为客户机应用检索出超过实际所需的数据，然后客户机代码对返回数据进行循环，以提取出需要的行。通常，这种实现并不令人满意。因此，对数据库进行了优化，以便快速有效地对数据进行过滤。让客户机应用（或开发语言）处理数据库的工作将会极大地影响应用的性能，并且使所创建的应用完全不具备可伸缩性。此外，如果在客户机上过滤数据，服务器不得不通过网络发送多余的数据，这将导致网络带宽的浪费。 WHERE子句的位置。在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后 WHERE子句操作符 123456789101112131415161718192021222324#检查单个值SELECT prod_name, prod_priceFROM productsWHERE prod_name = 'fuses';#列出小于10元的产品SELECT prod_name, prod_priceFROM productsWHERE prod_price &lt; 10;#不匹配检查SELECT vend_id, prod_nameFROM productsWHERE vend_id != 1003;#范围检查SELECT prod_name, prod_priceFROM productsWHERE prod_price BETWEEN 5 AND 10;#空值检查SELECT prod_nameFROM productsWHERE prod_price IS NULL; AND OR AND`操作符，必须满足所有条件 123SELECT prod_id, prod_price, prod_nameFROM productsWHERE vend_id = 103 AND prod_price &lt;= 10; OR操作符，匹配任一条件即可 123SELECT prod_name, prod_priceFROM productsWHERE vend_id = 1002 OR vend_id = 1003; AND和OR组合使用。列出价格为10元（含）以上且由1002或1003制造的所有产品 123SELECT prod_name, prod_priceFROM productsWHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10; NOTE： SQL的计算次序中AND的优先级比OR更高，因此在不加括号时会优先计算AND两侧条件 任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序。 IN IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配 1234SELECT vend_id, prod_name, prod_priceFROM productsWHERE vend_id IN (1002,1003)ORDER BY prod_name; NOTE：IN操作符优点 在使用长的合法选项清单时， IN操作符的语法更清楚且更直观。 在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。 IN操作符一般比OR操作符清单执行更快。 IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。 NOT WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。 1234SELECT vend_id, prod_name, prod_priceFROM productsWHERE vend_id NOT IN (1002,1003)ORDER BY prod_name; NOTE：MySQL中的NOT MySQL 支 持 使 用 NOT 对 IN 、 BETWEEN 和EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。 LIKENOTE： 通配符（wildcard）：用来匹配值的一部分的特殊字符 搜索模式（search pattern）：由字面值、通配符或两者组合构成的搜索条件 谓词（predicate）： 操作符何时不是操作符？答案是在它作为谓词（ predicate）时。从技术上说， LIKE是谓词而不是操作符。虽然最终的结果是相同的，但应该对此术语有所了解 百分号（%）通配符。 例：找出所有以词jet起头的产品 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE 'jet%'; 匹配任意位置 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '%anvil%'; 找出s起头以e结尾所有产品 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE 's%e'; NOTE： 注意尾空格：尾空格可能会干扰通配符匹配。例如，在保存词anvil 时 ， 如 果 它 后 面 有 一 个 或 多 个 空 格 ， 则 子 句 WHEREprod_name LIKE ‘%anvil’将不会匹配它们，因为在最后的l后有多余的字符。解决这个问题的一个简单的办法是在搜索模式最后附加一个%。一个更好的办法是使用函数 注意NULL：虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。即使是WHERE prod_name LIKE ‘%’也不能匹配用值NULL作为产品名的行 下划线（_）通配符。用途与%一样，但下划线只匹配单个字符而不是多个字符。 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '_ ton anvil'; 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '% ton anvil'; NOTE： 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据 正则表达式 基本字符匹配。 1234SELECT prod_idFROM productsWHERE prod_name REGEXP '.000';ORDER BY prod_name; NOTE：匹配不区分大小写。 MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXPBINARY 'JetPack .000' 进行OR匹配。也可以给出两个以上的OR条件，如1000|2000|3000 1234SELECT prod_idFROM productsWHERE prod_name REGEXP '1000|2000';ORDER BY prod_name; 匹配几个字符之一。使用正则表达式[123]定义一组数字，匹配1或2或3 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[123] Ton';ORDER BY prod_name; 范围匹配 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[1-5] Ton';ORDER BY prod_name; 匹配特殊字符。如果使用.，则会匹配任意字符 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '\\\\.';ORDER BY prod_name; NOTE： 匹配\\。为了匹配\\本身，需要使用\\\\\\ **\\或\\\\?**。多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（ MySQL自己解释一个，正则表达式库解释另一个）。 匹配字符类 匹配多个实例 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '\\\\([0-9] sticks?\\\\)';ORDER BY prod_name; 分析：正则表达式\\\\([0-9] sticks?\\\\)需要解说一下。 \\\\(匹配(，[0-9]匹配任意数字（这个例子中为1和5），sticks?匹配stick和sticks（ s后的?使s可选，因为?匹配它前面的任何字符的0次或1次出现），\\\\)匹配)。没有?，匹配stick和sticks会非常困难 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[[:digit:]]{4}';ORDER BY prod_name; 分析：[:digit:]匹配任意数字，因而它为数字的一个集合。 {4}确切地要求它前面的字符（任意数字）出现4次，所以[[:digit:]]{4}匹配连在一起的任意4位数字 定位符 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '^[0-9\\\\.]';ORDER BY prod_name; 分析：之前的例子都是匹配一个串中任意位置的文本。^[0-9\\\\.]只在.或任意数字为串中第一个字符时才匹配它们 NOTE：使REGEXP起类似LIKE的作用。LIKE和REGEXP的不同在于， LIKE匹配整个串而REGEXP匹配子串。利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一样。 计算字段 例：vendors表包含供应商名和位置信息。假如要生成一个供应商报表，需要在供应商的名字中按照name(location)这样的格式列出供应商的位置。此报表需要单个值，而表中数据存储在两个列vend_name和vend_country中。此外，需要用括号将vend_country括起来。 123SELECT Concat(vend_name, '(', vend_country, ')')FROM vendorsORDER BY vend_name; 使用RTrim()函数删除数据右侧多余的空格来整理数据。也可以使用LTrim()删除左边的空格，Trim()删除左右两边的空格 123SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')')FROM vendorsORDER BY vend_name; 使用别名。使用AS关键字将vend_title作为新计算列的名字 1234SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')') ASvend_titleFROM vendorsORDER BY vend_name; NOTE： 别名的其他用途。别名还有其他用途。常见的用途包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它。 导出列。别名有时也称为导出列（ derived column），不管称为什么，它们所代表的都是相同的东西。 执行算术运算 1234567SELECT prod_id, quantity, item_price, order_num, quantity * item_price AS expanded_priceFROM orderitemsWHERE order_num = 20005; 函数NOTE：函数没有SQL的可移植性强。 能运行在多个系统上的代码称为可移植的（ portable）。相对来说，多数SQL语句是可移植的，在SQL实现之间有差异时，这些差异通常不那么难处理。而函数的可移植性却不强。几乎每种主要的DBMS的实现都支持其他实现不支持的函数，而且有时差异还很大。 为了代码的可移植，许多SQL程序员不赞成使用特殊实现的功能。虽然这样做很有好处，但不总是利于应用程序的性能。如果不使用这些函数，编写某些应用程序代码会很艰难。必须利用其他方法来实现DBMS非常有效地完成的工作。 如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义 本文处理函数 123SELECT vend_name, Upper(vend_name) AS vend_name_upcaseFROM vendorsORDER BY vend_name; 常用文本处理函数 Soundex()通过发音字符和音节检索 123SELECT cust_name, cust_contactFROM customersWHERE Soundex(cust_contact) = Soundex('Y Lie'); 常用日期和时间处理函数 检索2005年9月1日订单记录 123SELECT order_date, cust_id, order_numFROM ordersWHERE Date(order_date) = '2005-09-01'; 检索2005年9月所有订单 123SELECT cust_id, order_numFROM ordersWHERE Year(order_date) = 2005 AND Month(order_date) = 9; 数值处理函数 汇总数据 AVG()函数 12SELECT AVG(prod_price) AS avg_priceFROM products; 123SELECT AVG(prod_price) AS avg_priceFROM productsWHERE vend_id = 1003;#返回特定供应商产品平均价格 NOTE： **只用于单个列 AVG()**。只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。 NULL值。AVG()函数忽略列值为NULL的行 COUNT()函数 123#返回customers表中客户的总数SELECT COUNT(*) AS num_custFROM customers; 123#只对具有电子邮件地址的客户计数SELECT COUNT(cust_email) AS num_custFROM customers; MAX()函数 123#返回products表中最贵物品的价格SELECT MAX(prod_price) AS max_priceFROM products; NOTE： 对非数值数据使用MAX()。虽然MAX()一般用来找出最大的数值或日期值，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行 NULL值。MAX()函数忽略列值为NULL的行。 MIN()函数 12SELECT MIN(prod_price) AS min_priceFROM products; SUM()函数 12345678#检索订购物品的总数SELECT SUM(quantity) AS items_orderedFROM orderitemsWHERE order_num = 20005;#合计计算值SELECT SUM(item_price * quantity) AS total_priceFROM orderitemsWHERE order_num = 20005; 聚集不同值，DISTINCT 1234#平均值只考虑各个不同的价格SELECT AVG(DISTINCT prod_price) AS avg_priceFROM productsWHERE vend_id = 1003; 组合聚集函数 12345SELECT COUNT(*) AS num_items, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avgFROM products; 分析：这里用单条SELECT语句执行了4个聚集计算，返回4个值（products表中物品的数目，产品价格的最高、最低以及平均值） 分组数据 GROUP BY创建分组 1234#对每个vend_id计算num_prods一次SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_id; NOTE： GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集计算语句外， SELECT语句中的每个列都必须在GROUP BY子句中给出。 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后， ORDER BY子句之前。 1234#使用ROLLUP对每个组及每个分组汇总SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_id WITH ROLLUP; HAVING过滤分组 1234SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_idHAVING COUNT(*) &gt;= 2; WHERE与HAVING同时使用的情况 123456#通过WHERE进一步过滤上面的例子SELECT vend_id, COUNT(*) AS num_prodsFROM productsWHERE prod_price &gt;= 10GROUP BY vend_idHAVING COUNT(*) &gt;= 2; ORDER BY与GROUP BY 1234SELECT order_num, SUM(quantity*item_price) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantity*item_price) &gt;= 50; 123456#将总计订单价格排序输出SELECT order_num, SUM(quantity*item_price) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantity*item_price) &gt;= 50ORDER BY ordertotal; 子查询1234567891011#检索订购物品TNT2的所有客户#通过客户ID查询客户信息SELECT cust_name, cust_contactFROM customers#外部查询，通过返回的订单号查询客户IDWHERE cust_id IN(SELECT cust_id FROM orders #内部查询，检索包含TNT2的所有订单编号 WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2')); NOTE： 列必须匹配。在WHERE子句中使用子查询（如这里所示），应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。 子查询和性能。这里给出的代码有效并获得所需的结果。但是，使用子查询并不总是执行这种类型的数据检索的最有效的方法。 联结表12345#创建联结SELECT vend_name, prod_name, prod_priceFROM vendors, productsWHERE vendors.vend_id = products.vend_idORDER BY vend_name, prod_name; NOTE： 完全限定列名。在引用的列可能出现二义性时，必须使用完全限定列名（用一个点分隔的表名和列名）。如果引用一个没有用表名限制的具有二义性的列名， MySQL将返回错误。 不要忘了WHERE子句。应该保证所有联结都有WHERE子句，否则MySQL将返回比想要的数据多得多的数据。同理，应该保证WHERE子句的正确性。不正确的过滤条件将导致MySQL返回不正确的数据。 叉联结。有时我们会听到返回称为叉联结（ cross join）的笛卡儿积的联结类型。 内部联结 123SELECT vend_name, prod_name, prod_priceFROM vendors INNER JOIN productsON vendors.vend_id = products.vend_id; 分析：这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同 联结多个表 12345SELECT prod_name, vend_name, prod_price, quantityFROM orderitems, products, vendorsWHERE products.vend_id = vendors.vend_id AND orderitems.prod_id = products.prod_id AND order_num = 20005; 分析：显示编号为20005的订单中的物品。订单物品存储在orderitems表中。每个产品按其产品ID存储，它引用products表中的产品。这些产品通过供应商ID联结到vendors表中相应的供应商，供应商ID存储在每个产品的记录中。这里的FROM子句列出了3个表，而WHERE子句定义了这两个联结条件，而第三个联结条件用来过滤出订单20005中的物品 NOTE：性能考虑 MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害 对比子查询 1234567891011121314151617#返回订购产品TNT2的客户列表#子查询SELECT cust_name, cust_contactFROM customers#外部查询，通过返回的订单号查询客户IDWHERE cust_id IN(SELECT cust_id FROM orders #内部查询，检索包含TNT2的所有订单编号 WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2'));#联结查询SELECT cust_name, cust_contactFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_id AND orderitems.order_num = orders.order_num AND prod_id = 'TNT2';","link":"/2020/06/10/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"【Spring源码】深入理解Spring IoC","text":"一开始学习Spring的时候就接触IoC了，作为Spring第一个最核心的概念，我们在解读它的源码之前必须要对其有深入的认识，本篇主要介绍IoC基本概念和各个组件。 IoC介绍IoC全称为Inversion of Control即“控制反转”，它还有一个别名DI（Dependency Injection），即“依赖注入”。 如何理解“控制反转”？关键在于我们需要回答下面四个问题： 谁控制谁 控制什么 为什么是反转 哪些方面反转了 回答这四个问题前，我们先看IoC的定义： 所谓IoC，就是由Spring IoC容器来负责对象的生命周期和对象之间的关系。 这句话是IoC理论的核心，如何来理解这句话？我们引用一个例子来阐述。 找女朋友，一般情况下是如何找的呢？首先我们要根据自己的喜好（漂亮、身材好、性格好）找一个妹子，然后到处打听她的兴趣爱好、电话号码，然后各种投其所好追到手。如下： 123456789101112131415161718192021222324/** * 年轻小伙子 */public class YoungMan { private BeautifulGirl beautifulGirl; YoungMan(){ // 可能你比较厉害，指腹为婚 // beautifulGirl = new BeautifulGirl(); } public void setBeautifulGirl(BeautifulGirl beautifulGirl) { this.beautifulGirl = beautifulGirl; } public static void main(String[] args){ YoungMan you = new YoungMan(); BeautifulGirl beautifulGirl = new BeautifulGirl(\"你的各种条件\"); beautifulGirl.setxxx(\"各种投其所好\"); // 然后你有女票了 you.setBeautifulGirl(beautifulGirl); }} 这就是我们通常做事的方式，如果我们需要某个对象，一般都是采用这种直接创建的方式（new BeautifulGirl()），这个过程复杂而又繁琐，而且我们必须要面对每个环节，在使用完成之后还需要复杂地销毁它，这种情况下我们的对象与它所依赖的对象耦合在一起。 其实我们需要思考一个问题，我们每次用到自己依赖的对象真的需要自己去创建吗？我们知道，我们依赖的对象其实并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是我们主动去创建的还是别人送给我们的，其实并不是那么重要。 这个给我们送东西的“人”就是IoC，在上面的例子中，它就相当于一个婚介公司，作为一个婚介公司它管理者很多男男女女的资料，当我们需要一个女朋友的时候，直接跟婚介公司提出我们的需求，婚介公司则会根据我们的需求提供一个妹子给我们，我们只需要负责谈恋爱就行了。 作为婚介公司的IoC帮我们省略了找女朋友的繁琐过程，将原来的主动寻找变成了现在的被动接受，更加简介轻便。原来需要各种鞍前马后亲力亲为的事，现在直接有人把现成的送过来，多么美妙的事情啊。所以，IoC的理念就是让别人为你服务，如下图（摘自Spring揭秘）： 在没有引入IoC的时候，被引入的对象直接依赖于被依赖的对象，有了Ioc后，两者及他们的关系都是通过Ioc Service Provider来统一管理维护的。被注入的对象需要什么，直接跟IoC Service Provider打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到IoC Service Provider为被注入对象服务的目的。所以有了IoC，原来需要什么东西自己去拿，现在是需要什么让别人（IoC Service Provider）送过来。 现在看看上面那四个问题，答案就很明显了： 谁控制谁：在传统的开发模式下，我们都是采用直接new一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了IoC容器后，则直接由IoC容器来控制。所以“谁控制谁”，当然是IoC容器控制对象。 控制什么：控制对象 为什么是反转：没有IoC的时候我们都是在自己对象中主动区创建被依赖的对象，这就是正转。但是有了IoC后，所依赖的对象直接由IoC容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。 哪些方面反转了：所依赖对象的获取被反转了。 妹子有了，但是如何拥有妹子呢？这也是一门学问。 可能你比较厉害，刚出生就指腹为婚了 大多数情况我们还是会考虑自己想要什么样的妹子，所以还是需要向婚介公司打招呼的 还有一种情况就是，你根本不知道自己想要什么样的妹子，直接跟婚介公司说，我想要一个妹子 注入形式所以，IoC Service Provider为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、setter方法注入、接口注入 构造方法注入顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。 123YoungMan(BeautifulGirl beautifulGirl) { this.beautifulGirl = beautifulGirl;} 构造方法注入比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你制定了媳妇 setter方法注入对于JavaBean对象而言，我们一般都是通过getter和setter方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的setter方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。 12345678public class YoungMan { private BeautifulGirl beautifulGirl; public void setBeautifulGirl(BeautifulGirl beautifulGirl) { this.beautifulGirl = beautifulGirl; }} 相比于构造器注入，setter方式注入会显得比较宽松灵活一些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼。 接口方式注入接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般不推荐这种方式。感兴趣的可以看看《依赖注入的三种实现形式 —— 接口注入（Interface Injection）》 推荐文章关于 IoC 理论部分，笔者不在阐述，这里推荐几篇博客阅读： 《谈谈对 Spring IoC 的理解》 《Spring 的 IoC 原理[通俗解释一下]》 《Spring IoC 原理（看完后大家可以自己写一个spring）》 各个组件先看下图（摘自：http://singleant.iteye.com/blog/1177358） 该图为ClassPathXmlApplicationContext的类继承体系结构，虽然只有一部分，但是它基本上包含了IoC体系中大部分的核心类和接口。 下面我们就针对这个图进行简单的拆分和补充说明。 Resource 体系org.springframework.core.io.Resource，对资源的抽象。它的每一个实现类都代表了一种资源的访问策略，如ClassPathResource、RLResource、FileSystemResource 等。 ResourceLoader 体系有了资源，就应该有资源加载，Spring利用org.springframework.core.io.ResourceLoader来进行统一资源加载，类图如下： （关于Resource和ResourceLoader的源码解析，见…） BeanFactory 体系org.springframework.beans.factory.BeanFactory，是一个非常纯粹的bean容器，它是IoC必备的数据结构，其中BeanDefinition是它的基本结构。BeanFactory内部维护着一个BeanDefinition map，并可根据BeanDefinition的描述进行bean的创建和管理。 BeanFactory 有三个直接子类ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 。 DefaultListableBeanFactory 为最终默认实现，它实现了所有接口。 BeanDefinition 体系org.springframework.beans.factory.config.BeanDefinition ，用来描述 Spring 中的 Bean 对象。 BeanDefinitionReader 体系org.springframework.beans.factory.support.BeanDefinitionReader 的作用是读取 Spring 的配置文件的内容，并将其转换成 Ioc 容器内部的数据结构 ：BeanDefinition 。 关于BeanDefinitionReader 的源码解析，见如下文章： ApplicationContext 体系org.springframework.context.ApplicationContext ，这个就是大名鼎鼎的 Spring 容器，它叫做应用上下文，与我们应用息息相关。它继承 BeanFactory ，所以它是 BeanFactory 的扩展升级版，如果BeanFactory 是屌丝的话，那么 ApplicationContext 则是名副其实的高富帅。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有： 继承 org.springframework.context.MessageSource 接口，提供国际化的标准访问策略。 继承 org.springframework.context.ApplicationEventPublisher 接口，提供强大的事件机制。 扩展 ResourceLoader ，可以用来加载多种 Resource ，可以灵活访问不同的资源。 对 Web 应用的支持。 下图来源：https://blog.csdn.net/yujin753/article/details/47043143 小结上面的五个体系可以说是 Spring IoC 中最核心的部分，后面的博文也是针对这五个部分进行源码分析。其实IoC乍一看还是挺简单的，无非就是将配置文件（暂且认定是xml文件）进行解析，然后放到一个Map里面就差不多了。初看有道理，其实要面临的问题还是有很多的。 此系列博文为笔者学习、研究 Spring 机制和源码的学习笔记，会涉及参考别人的博文和书籍内容，如有雷同，纯属借鉴，当然 LZ 会标明参考来源。同时由于知识面和能力的问题，文章中难免会出现错误之处，如有，望各位大佬指出，不胜感激。","link":"/2020/08/21/%E3%80%90Spring%E6%BA%90%E7%A0%81%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring-IoC/"}],"tags":[{"name":"Homebrew","slug":"Homebrew","link":"/tags/Homebrew/"},{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"}],"categories":[{"name":"工具安装及配置","slug":"工具安装及配置","link":"/categories/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"命令","slug":"命令","link":"/categories/%E5%91%BD%E4%BB%A4/"},{"name":"工具使用问题与解决方案","slug":"工具使用问题与解决方案","link":"/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"源码","slug":"源码","link":"/categories/%E6%BA%90%E7%A0%81/"}]}